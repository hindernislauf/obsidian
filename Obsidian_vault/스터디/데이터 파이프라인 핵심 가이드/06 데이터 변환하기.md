# 변경 데이터 캡처 모델링 (CDC)

- CDC를 통해 수집된 데이터는 데이터 웨어하우스에 특정 방식으로 저장됨
- [표 6-9]는 CDC를 통해 수집된 'Orders_cdc' 테이블의 내용
	- 소스 시스템의 세 가지 주문 내역(OrderId 1, 2, 3)에 대한 변경 사항이 기록됨

| EventType | OrderId | OrderStatus | LastUpdated         |
| --------- | ------- | ----------- | ------------------- |
| insert    | 1       | Backordered | 2020-06-01 12:00:00 |
| update    | 1       | Shipped     | 2020-06-09 12:00:25 |
| Delete    | 1       | Shipped     | 2020-06-10 9:05:12  |
| insert    | 2       | Backordered | 2020-07-011:00:00   |
| update    | 2       | Shipped     | 2020-07-09 12:15:12 |
| insert    | 3       | Backordered | 2020-07- 1113:10:12 |
- [표 6-9] Orders_cdc 테이블

#### Orders_cdc 테이블 생성 및 데이터 삽입 SQL

```sql
CREATE TABLE Orders_cdc
(
  EventType varchar(20),
  OrderId int,
  OrderStatus varchar(20),
  LastUpdated timestamp
);

INSERT INTO Orders_cdc
  VALUES('insert',1,'Backordered','2020-06-01 12:00:00');
INSERT INTO Orders_cdc
  VALUES('update',1,'Shipped','2020-06-09 12:00:25');
INSERT INTO Orders_cdc
  VALUES('delete',1,'Shipped','2020-06-10 9:05:12');
INSERT INTO Orders_cdc
  VALUES('insert',2,'Backordered','2020-07-01 11:00:00');
INSERT INTO Orders_cdc
  VALUES('update',2,'Shipped','2020-07-09 12:15:12');
INSERT INTO Orders_cdc
  VALUES('insert',3,'Backordered','2020-07-11 13:10:12');
```

[상세 설명 : CDC 데이터로 주문 상태 및 내역 확인]
- CDC를 사용하면 모든 주문의 현재 상태뿐만 아니라 전체 내역도 확인 가능
	- 주문 1의 레코드는 주문이 접수됐을 때 처음 생성되었지만, 주문 상태가 Backordered로 돼 있음
	- 8일 후 배송될 때 소스 시스템에서 레코드가 업데이트됨
	- 하루 후 레코드가 소스 시스템에서 삭제됨
		- `주문 1`: 처음 생성 시 `Backordered`, 8일 후 배송 시 업데이트됨, 하루 후 삭제됨
	- 주문 2도 비슷한 여정을 거쳤지만, 삭제된 적은 없음
		- `주문 2`: 유사한 여정, 삭제된 적 없음
	- 주문 3은 배치될 때 처음 삽입되었으며, 업데이트된 적이 없음
		- `주문 3`: 처음 삽입된 후 업데이트된 적 없음
	
	[요약 설명]
	- **OrderId 1**
		- 초기 `Backordered` 상태로 생성됨(`insert`)
		- 이후 `Shipped`로 상태가 업데이트되었으며(`update`)
		- 마지막에 삭제됨(`delete`)
	- **OrderId 2**
		- `Backordered`로 상태로 생성됨(`insert`)
		-  `Shipped` 상태로 업데이트(`update`)
	- **OrderId 3**
		- `Backordered` 상태로 생성된 주문(`insert`)

---

- 저장된 데이터를 모델링하는 방법은 데이터 모델이 답해야 하는 질문에 따라 상이함 
	- e.g. 운영 대시보드에서 각 주문 상태(`order_status`)의 현재 주문 수를 표시하려는 경우, 다음과 같은 SQL을 사용할 수 있음
```sql
CREATE TABLE orders_current (
  order_status varchar(20),
  order_count int
);

INSERT INTO orders_current
  (order_status, order_count)
  -- 각 OrderId에 대해 가장 최신의 업데이트 값을 찾음(CTE 사용)
  WITH o_latest AS
  (
    SELECT
       OrderId,
       MAX(LastUpdated) AS max_updated   -- 주문별로 가장 최근 업데이트 시간
    FROM Orders_cdc
    GROUP BY orderid
  )
  
  -- 최신 상태의 주문을 orders_current 테이블에 삽입
  SELECT o.OrderStatus,
    Count(*) as order_count   -- 주문 상태별로 주문 수 계산
  FROM Orders_cdc o
  INNER JOIN o_latest   -- 최신 업데이트된 주문과 매칭
    ON o_latest.OrderId = o_latest.OrderId
      AND o_latest.max_updated = o.LastUpdated
  GROUP BY o.OrderStatus;   -- 주문 상태별로 그룹화하여 데이터 삽입
```

[주문 데이터의 상태 추적]
- 주문 데이터의 상태를 추적하는 방법과 SQL 쿼리를 통해 이를 표현하는 방법은 아래와 같음
- CTE를 사용하여 각 `OrderId`에 대한 최신 타임스탬프를 찾고, 이를 기반으로 주문의 최신 상태 `orderstatus`를 가져옴
	1. *CTE 사용*
		- CTE에서 `o_latest`라는 임시 테이블을 생성
		- 각 `OrderId`에 대해 가장 최신의 `LastUpdated` 타임스탬프 값을 구함
		  → 이를 통해 `MAX(LastUpdated)`를 사용하여 주문별로 가장 마지막 상태를 찾는 것
		- **CTE(Common Table Expression)**
			- SQL에서 일시적인 결과 집합을 정의할 때 사용하는 방법
			- 쿼리 내에서 반복적으로 사용할 수 있는 임시 테이블을 정의할 때 사용
			- 복잡한 쿼리를 더 읽기 쉽게 하고 여러 번 재사용 가능
			- `WITH`을 사용하여 정의
	2. *내부 조인(INNER JOIN)*
		- `Orders_cdc` 테이블과 `o_latest` CTE 결과를 INNER JOIN
		  →`OrderId`와 최신 타임스탬프가 일치하는 주문의 상태만 가져옴
	3. *출력 결과*
		- 'Shipped' 상태인 주문은 2개
		- 'Backordered' 상태인 주문은 1개
```sql
SELECT * FROM orders_current; 
```
```
order_status | order_count
-------------|-------------
Shipped      |           2
Backordered  |           1
```

[삭제된 데이터 처리 문제 발생]
- `OrderId 1`의 최신 상태가 'Shipped'로 나오지만, 해당 주문은 소스 데이터베이스에서 삭제되었음
    → 삭제된 주문을 대시보드에서 제외하는 것이 적절
- 주문이 취소되어 소스 시스템에서 삭제된 경우, **삭제된 데이터를 무시하는 방식으로 모델을 수정함**
    → 좋은 시스템 설계는 아니지만 삭제 반영이 되지 않은 것을 해결하기 위해 위와 같이 가정해서 진행
	- `Orders_cdc` 테이블과 CTE(`o_latest`)를 내부 조인한 후, 가장 최신 상태가 삭제(`delete`)되지 않은 주문들만 필터링
	- 각 주문 상태별로 `order_count`를 계산해 `orders_current` 테이블에 삽입
```sql
-- orders_current 테이블의 모든 데이터를 삭제(초기화)
TRUNCATE TABLE orders_current;

INSERT INTO orders_current
  (order_status, order_count)
  WITH o_latest AS 
  (
    SELECT
       OrderId,
       MAX(LastUpdated) AS max_updated
    FROM Orders_cdc
    GROUP BY orderid
  )

  SELECT o.OrderStatus,
    Count(*) AS order_count
  FROM Orders_cdc o
  INNER JOIN o_latest
    ON o_latest.OrderId = o_latest.OrderId
      AND o_latest.max_updated = o.LastUpdated
  WHERE o.EventType <> 'delete'  -- 삭제된 주문은 제외
  GROUP BY o.OrderStatus;
```

- *출력 결과* : 삭제된 주문은 제외됨
	- 'Shipped' 상태인 주문 1개
	- 'Backordered' 상태인 주문 1개
```sql
SELECT * FROM orders_current; 
```
```
order_status | order_count
-------------|-------------
Shipped      |           1
Backordered  |           1
```

[CDC 데이터를 활용한 변경 분석]
- CDC에서 수집한 데이터는 데이터 변경 사항을 분석하고, 비즈니스 인사이트를 얻는 데 유용함
- e.g. 데이터 분석가 : 주문 상태가 `Backordered`에서 `Shipped`로 전환되는 데 걸리는 평균시간을 계산
	- CDC 데이터를 사용해 **주문 상태 변화(Backordered → Shipped) 시간을 분석**하는 것이 가능하며, CTE를 활용한 복잡한 쿼리를 통해 구현할 수 있음
	- **계산 방법** : 두 개의 CTE를 사용해 각 주문이 `Backordered` 및 `Shipped` 된 첫 번째 날짜를 찾고, 두 날짜의 차이를 계산
	    → 계산을 통해 주문 지연(Backordered) 및 배송 완료(Shipped)된 각 주문이 `Backordered` 상태에 있었던 날짜 확인 가능
	- 위 계산에서는 아직 배송되지 않은 주문(`OrderId 3`)은 의도적으로 무시됨
	    →  해당 주문은 아직 `Shipped` 상태로 전환되지 않았기 때문
- SQL 쿼리를 구현하면 아래와 같음
```sql
CREATE TABLE orders_time_to_ship (
  OrderId int,
  backordered_days interval
);

INSERT INTO orders_time_to_ship
  (OrderId, backordered_days)
WITH o_backordered AS
(
  SELECT
     OrderId,
     MIN(LastUpdated) AS first_backordered
  FROM Orders_cdc
  WHERE OrderStatus = 'Backordered'
  GROUP BY OrderId
),
o_shipped AS
(
  SELECT
     OrderId,
     MIN(LastUpdated) AS first_shipped
  FROM Orders_cdc
  WHERE OrderStatus = 'Shipped'
  GROUP BY OrderId
)
SELECT b.OrderId,
  first_shipped - first_backordered
    AS backordered_days
FROM o_backordered b
INNER JOIN o_shipped s on s.OrderId = b.OrderId;
```
-  *o_backordered*
    - 각 주문(`OrderId`)의 `Backordered` 상태가 처음 발생한 날짜(`first_backordered`)를 찾음
- *o_shipped*
    - 각 주문(`OrderId`)의 `Shipped` 상태가 처음 발생한 날짜(`first_shipped`)를 찾음

- 각 주문의 주문 지연 시간(backordered_days) 확인 및 평균(AVG()) 계산하여 원하는 값 반환
```sql
SELECT * FROM orders_time_to_ship; 
```
```
orderid | backordered_days
--------|------------------
      1 | 8 days 00:00:25
      2 | 8 days 01:15:12
```

```sql
SELECT AVG(backordered_days) 
FROM orders_time_to_ship;
```
```
avg
-----------------
8 days 00:37:48.5
```

[CDC 데이터 사용 시 고려사항]
- 전체 변경 기록을 가진 데이터는 여러 가지 사용 사례가 있지만, 완전히 새로 로드되었거나 추가 전용인 데이터 모델링에는 몇 가지 고려사항이 있음
- 전체 새로 로드 vs 증분 로드
    - **전체 새로 로드**
        - 장점: 모델이 단순해지며, 업데이트와 삭제 처리의 복잡성이 감소됨
        - 단점: 전체 데이터를 매번 새로 로드해야 하므로, 데이터 처리 시간이 길어지면 성능이 저하됨
	- **증분 로드**
        - 장점: 필요한 변경 사항만을 로드하므로 처리 속도가 개선되어 성능이 향상될 수 있음
        - 단점: 업데이트와 삭제를 모두 처리해서 시스템 설계와 유지보수가 복잡해질 수 있음(모델의 복잡성 증가)
- 따라서, CDC 데이터를 사용할 때 성능 향상과 복잡성 간의 균형을 고려해야 함
	- 증분 로드는 성능을 개선할 수 있지만 추가적인 복잡성을 초래할 수 있고
	- 복잡성을 줄이기 위해 전체 새로 로드를 선호할 수도 있음