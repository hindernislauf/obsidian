# 도커 설치
- https://docs.docker.com/engine/install/ubuntu/
	```
	# Add Docker's official GPG key:
	sudo apt-get update
	sudo apt-get install ca-certificates curl
	sudo install -m 0755 -d /etc/apt/keyrings
	sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc
	sudo chmod a+r /etc/apt/keyrings/docker.asc
	
	# Add the repository to Apt sources:
	echo \
	  "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \
	  $(. /etc/os-release && echo "$VERSION_CODENAME") stable" | \
	  sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
	sudo apt-get update
	```
	
	```
	# 설치확인
	systemctl status docker
	```

- # 도커의 기본 개념
	- ## 도커(docker)
		- 컨테이너(container)라고 부르는 패키지 형태로 소프트웨어를 배ㅎ포하는 OS-level 가상화 기술을 사용 한 PaaS(platform as a service)제품이다.
		- 컨테이너 관리하고 소프트웨어를 도커 엔진(Docker Engine)이라고 부른다.
	- ## 가상화 (virtualization)
		- 물리적인 자원을 논리적인 자원으로 변환해서 사용하는 것
		- ### 종류
		1. 호스트 가상화(Host virtualization)
		2. 하이퍼 바이저 가상화 (Hypervisor virtualization)
			2-1) 전 가상화(Full virtualization) : 하드웨어를 사아화
			2-2) 반 가상화(Para-virtualization) : 하드웨어를 가상화하진 않음
		3. OS level 가상화(OS level virtualization), 컨테이너 가상화(container virtualization
		
			bins(바이너리)/libs(라이브러리)
			컨테이너 는 OS가 아니다!!
- # 도커의 구조
	- ## 도커엔진(docker engine) 
		- 애플리케이션을 컨테이너화 하기 위한 오픈 소스 컨테이너화 기술(open source containerization technology)
		- 도커 엔진은 다음과 같은 클라이언트-서버 역할을 한다.
			- dockerd 와 같은 데몬 프로세스가 실행되는 서버
			- 도커 데몬과 의사소통하기 위한 API 역할
			- 커멘드 라인 인터페이스 (CLI) 클라이언트 docker
		![](https://i.imgur.com/bOYE8Tw.png)
	- ## 도커 데몬(docker daemon, dockerd)
		- 호스트(host)에서 메모리에 상주하여 백그라운드에 컨테이너를 관리하는 프로세스
		- 클라이언트의 요청을 기다리고 있다가 요청이 발생하면 이에 적절히 대응함 
		- 즉, 메모리에 상주하면서 특정 요청이 오면 즉시 대응할 수 있도록 대기 중인 프로세스를 의미
		- 도커 사용자는 도커 데몬과 통신함
	- ## 도커 이미지(docker image)
		- 도커 이미지는 도커 컨테이너를 실행하기 위해 필요한 모든 것을 모아놓은 패키지
		-  기본적으로 코드, 라이브러리 및 컨테이너가 어떻게 인스턴스화 되어야하는지에 대한 내용 포함
		- 해당 소프트웨어 구성물이 어떻게 실행되어야 하는지도 포함
		- 도커 이미지가 가상머신 환경의 **스냅샷**이라고도 볼수 있음
		- 즉, 실행 중인 도커 컨테이너의 특정 시점을 나타낸다라고 할수 있음
	- ## 도커 컨테이너(docker container)
		- 실행 가능한 도커 이미지의 인스턴스
		- 하나의 프로세스라고도 볼수 있음(다른 프로세스들과 완전히 분리된)
		- 도커 컨테이너는 가상화된 런타임 환경
			- 런타임(runtime): 프로그램이 실행되고 있는 동안의 동작을 의미
	- ## 도커 레지스트리(docker registry)
		- 도커 이미지 저장소, 도커 이미지가 보관되는 곳
		- 기본적으로 도커 허브(docker hub)에 있는 이미지를 찾도록 설정되어 있음
	![400](https://i.imgur.com/R0pw52A.png) 
	- ## containerd vs runc 차이점
		- runc 는 OCI(Open Container Image) 인터페이스를 실행하기 위한 lowest level 구성요소
			- OCI (Open Container Image)
				- 컨테이너 표준 사양을 책정하기 위해 만들어진 단체
				- 처음에는 도커가 컨테이너의 표준이었는데 다양한 컨테이너 런타임이 생김
					-> 업계 표준이 필요함
				- 도커, CoreOS, 구글, IBM, 레드햇, AWS, VMware, HP, EMC, Pivotal, 마이크로소프트, 리눅스 파운데이션 등 참가
		- runc는 containerd의 구성 요소로써 커널 레벨에서 컨테이너를 실행한다.
		- containerd는 컨테이너 라이프 사이클을 완벅하게 관리하는 컨테이너 런타임이다.
			- 컨테이너 라이프 사이클: 이미지 전송/ 저장부터 컨테이너 실행 및 네트워크 관리 등을 포함
		- containerd는 네트워크, 이미지 전송/저장 등과 같이 runc보다 더 포괄적으로 관여하는 부분이 많음
			- runc는 container를 실행하는 그 자체의 기능에만 집중함.
			- containerd는 runc가 잘 실행할수 있도록 도와준다고 보면됨.
		- 널게 보면 도커 엔진은 유저의 커맨드 입력받고 도커 레지스트리에서 이미지를 다운로드 받는 등의 일을 함.
	- ## hello-world의 의미
		```
		이미지 build
		컨테이너 pull
		허브 run
		
		docker ps, docker run <- 옜날 명령어 (image인지 container 인지 혼동)
		docker image ls, docker container ls
		docker container run
		```
		- 도커 hello-world
			```
			$ docker container run hello-world
			```
		- 도커 이미지 확인
			```
			$ docker image ls
			```
		- 도커 컨테이너 확인
			```
			- 작동중인 컨테이너 : $ docker container ls
			- 모든 컨테이너 : $ docker container ls -a
			```
		- 도커 containerd 확인
			```
			$ sudo -i
			cd /run/docker
			ll
			아무것도 없음을 확인
			cd ..
			cd runtime-runc/
			moby : 초기 도커 프로젝트 이름
			```
	- ## docker container run
		```
		우분투 이미지를 컨테이너로 실행
		docker image ls
		ubuntu -> image id 
		docker container run (image id)
		docker container ls -a
		```
		- 이미지는 컨테이너로 변환되어 하나의 인스턴스가 됨
		- 실행의 컨테이너는 IP 주소를 가지는 하나의 독립된 서버처럼 동작함
		- 각 컨테이너는 고유의 IP 주소와 포트 번호를 가지고 있음
		- 컨테이너는 실행할 때마다 새로운 IP 주소를 가지게 됨(이전 이력과 관계없음)
- # 도커 기본 명령어
	- ## 컨테이너 네트워크
		- ### (터미널1) 컨테이너 내부에서 bash shell 실행
			```
			$ docker container run -it ubuntu /bin/bash
			```
			- i (interactive) 옵션 : 키보드 입력을 컨테이너 표준 입력에 연결해 컨테이너 shell에 보냄
			- t (tty) 옵션 : 터미널을 통해 대화형 조작이 가능하게 함
			- 운영체제 처럼 보이지만 아니다
		- ### (터미널2)새로운 터미널을 열고 컨테이너 ls 확인
			```
			$ docker container ls
			```
		- ### 터미널2에서 터미널1에 실행중인 컨테이너 접속
			```
			$ docker exec -it {컨테이너ID} bash
			```
		- ### 실행중인 컨테이너 종료
			```
			docker container stop {컨테이너ID}
			```
	- ## 도커 이미지 변경후 저장
		```
		(터미널1)docker container run -it ubuntu /bin/bash
		(터미널1)ifconfig
			apt-get update&&apt-get install net-tools
		(터미널2)docker container ls
		(터미널2)docker container commit {컨테이너ID} my-ubuntu:0.1
		(터미널2)docker image ls
		
		이미지 삭제
		(호스트)docker image ls
			-> 삭제할 IMAGE ID 확인 
		(호스트)docker image rm {이미지ID}
		```
	- ## 호스트 <-> 컨테이너 간 파일 전송
		```
		호스트 -> 컨테이너 파일 전송
		호스트 터미널에서 실행
		(터미널1) mkdir work&& cd $_&&vim while_loop.py 
		docker container cp ./while_loop.py 75fe5a9aace8:/home
		
		컨테이너 -> 호스트 파일 전송
		호스트 터미널에서 실행
		(터미널1)docker container cp 75fe5a9aace8:/home/while_loop.py ./
		```
- # 부록
	- pyenv 설치 & 가상환경 만들기 & 라이브러리 설치
	```
	sudo apt-get update; sudo apt-get install make build-essential libssl-dev zlib1g-dev \
	
	libbz2-dev libreadline-dev libsqlite3-dev wget curl llvm \
	
	libncursesw5-dev xz-utils tk-dev libxml2-dev libxmlsec1-dev libffi-dev liblzma-dev
	
	curl https://pyenv.run | bash
	복사
	export PYENV_ROOT="$HOME/.pyenv"
	[[ -d $PYENV_ROOT/bin ]] && export PATH="$PYENV_ROOT/bin:$PATH"
	eval "$(pyenv init -)"
	
	eval "$(pyenv virtualenv-init -)"
	
	vim .bashrc
	제일 하단에 붙여넣기
	export PYENV_ROOT="$HOME/.pyenv"
	[[ -d $PYENV_ROOT/bin ]] && export PATH="$PYENV_ROOT/bin:$PATH"
	eval "$(pyenv init -)"
	eval "$(pyenv virtualenv-init -)"
	
	쉘 재실행
	exec $SHELL
	
	설치
	pyenv install 3.11.9
	
	가상환경 생성
	pyenv virtualenv 3.11.9 py3_11_9
	```

- # PostgreSQL
- ...

![](https://i.imgur.com/1asNV6n.png)

- # 배포시스템 구조 이해하기
	- ## 도커 컴포즈(docker compose)
		- 도커 컴포즈(docker compose)는 여러 개의 컨테이너를 가동할때 사용하는 도커 애플리케이션
		- 도커 컴포즈를 사용하기 위해서는 docker-compose.yml이라는 YAML파일을 사용
	- ## YAML(YAML Ain't Markup Language)
		- "YAML은 마크업 언어가 아니다"
		- 기존 사용하던 JSON의 불편함을 해소하기 위해 만들어진 언어, XML과 비슷하지만 다름
		- 주로 설정 파일(configuration file)에 사용
		- 파이썬과 마찬가지로 들여쓰기가 중요함
		- 리스트 개념을 사용하기 위해 하이픈(-) 사용
		- 확장자는 ~.yml
	- ## 가상환경에서 YAML 실습
		- ### pyyaml 설치
		```
		# 가상환경 접속
		$ pyenv activate py3_11_9
		
		# pyyaml 설치
		$ pip install pyyaml
		```
		
		```
		$ cd work
		
		$ vim yaml_exampl.yml
		
		apiVersion: v1
		kind: Pod
		metadata:
		  name: nginx
		spec:
		  containers:
		  - name: nginx
		    image: nginx:latest
		  - name: ubuntu
		    image: ubuntu:latest
		    
		  - ~~ <- 리스트의 시작
		```
		
		```
		$ python
		
		>>> import yaml
		>>> raw = open('/home/ubuntu/work/yaml_exampl.yml', 'r+')
		>>> data = yaml.load(raw, Loader=yaml.SafeLoader)
		>>> data
		>>> {'apiVersion': 'v1', 'kind': 'Pod', 'metadata': {'name': 'nginx'}, 'spec': {'containers': [{'name': 'nginx', 'image': 'nginx:latest'}, {'name': 'ubuntu', 'image': 'ubuntu:latest'}]}}
		```
		
		```
		>>> data['apiVersion']
		'v1'
		
		>>> data['kind']
		'Pod'
		
		>>> data['metadata']
		{'name': 'nginx'}
		
		>>> data['metadata']['name']
		'nginx'
		```
		
		```
		>>> data['spec']
		{'containers': [{'name': 'nginx', 'image': 'nginx:latest'}, {'name': 'ubuntu', 'image': 'ubuntu:latest'}]}
		
		>>> data['spec']['containers']
		[{'name': 'nginx', 'image': 'nginx:latest'}, {'name': 'ubuntu', 'image': 'ubuntu:latest'}]
		
		>>> data['spec']['containers'][0]
		{'name': 'nginx', 'image': 'nginx:latest'}
		
		>>> data['spec']['containers'][0]['name']
		'nginx
		
		>>> quit()
		$ pyenv deactivate
		```
	- ## docker-compose-plugin
		- docker-compose 설치
		https://docs.docker.com/compose/install/linux/#install-using-the-repository
		```
		sudo apt-get update
		sudo apt-get install docker-compose-plugin
		
		$ docker compose version
		```
		- requirements.txt 수정
		```
		~/work/docker/flaskapp$ vim requirements.txt 
		
		scikit-learn==1.5.0
		flask==3.0.3
		psycopg2==2.9.9
		gunicorn==22.0.0 <- 추가 작성
		```
		- Dockerfile 수정
		```
		~/work/docker/flaskapp$ vim Dockerfile
		
		FROM python:3.11.9
		
		WORKDIR /usr/src/app
		
		COPY . .
		
		RUN python -m pip install --upgrade pip
		RUN pip install -r requirements.txt
		
		WORKDIR ./myapp
		
		CMD gunicorn main:app --bind 0.0.0.0:5000 <- 수정
		
		EXPOSE 5000
		
		# --bind (서로 연결이 되었는지 확인 하는것) 
		```
		- default.conf 파일 생성
		```
		~/work/docker/nginxtest$ vim default.conf
		
		server{
		  listen 80;
		  server_name localhost;
		
		  location /{
		    proxy_pass http://flasktest:5000;
		  }
		}
		```
		- Dockerfile 수정
		```
		~/work/docker/nginxtest$ vim Dockerfile
		
		FROM nginx:1.26.0
		
		RUN rm /etc/nginx/conf.d/default.conf <- 추가
		
		COPY default.conf /etc/nginx/conf.d/ <- 추가
		
		CMD ["nginx", "-g", "daemon off;"]
		```
		- docker-compose.yml 파일 작성
		```
		~/work/docker$ vim docker-compose.yml
		
		services:
		  flasktest:
		    build: ./flaskapp
		    networks:
		      - composenet01
		    restart: always
		      
		  nginxtest:
		    build: ./nginxtest
		    networks:
		      - composenet01
		      ports:       # 80번 포트에서 80번 포트로
		        - "80:80"
		      depends_on:  # flask 먼저 띄우고 nginx를 띄우겠다
		        -flasktest
		networks:
		  composenet01:
		  
		# networks 는 전부 생략 가능  
		```
		- 실행
		```
		$ docker compose up -d --build
		(-d 백그라운드 실행 --build ??)
		```
		
		```
		$ docker container ls
		
		$ docker network ls
		```
		- 이제 포트번호를 적지않고 IP주소만 입력하면 접속 가능함.
			오류 찾을때 -> 로그 찍어보기 (docker container ls -> status 확인)
		```
		# postgres 확인
		
		(base) a-35@A-35ui-iMac ~ % curl -d '{"input":["0.3"]}' -H "Content-Type: application/json" -X POST http://3.38.6.17/predict
		{"input":0.3,"predicted_output":1.63768}
		
		$ docker container ls
			-> docker-nginxtest CONTAINER ID
		$ docker container logs a9ff95ab8fc3
		
			# 성공 확인
			-> 58.122.170.40 - - [03/Jun/2024:05:30:36 +0000] "POST /predict HTTP/1.1" 200 41 "-" "curl/8.4.0" "-" 
		
		$ sudo -i -u postgres
		:~$ psql
		postgres=# \c ml
		ml=# \dt
		            List of relations
		 Schema |    Name     | Type  |  Owner   
		--------+-------------+-------+----------
		 public | pred_result | table | postgres
		(1 row)
		
		ml=# SELECT * FROM pred_result;
		 id | input | output  |         insert_dt          
		----+-------+---------+----------------------------
		  1 |   0.8 | 2.64146 | 2024-05-31 05:30:18.89141
		  2 |   0.6 | 2.23995 | 2024-05-31 07:40:03.336183
		  3 |   0.3 | 1.63768 | 2024-06-03 05:30:36.79021
		(3 rows)
		```
		- 컨테이너 정지
		```
		$ docker compose down
		
		# 확인
		$ docker container ls 
		$ docker network ls
		```

- # 응용
	- ## 목차
	1. 도커로 PostgreSQL 배포학
	2. 도커 볼륨
	3. 도커로 nginx, flask, PostgreSQL 함께 배포하기
	4. beyond 도커
	
	- PostgreSQL 이미지 pull받기
	```
	$ docker image pull postgres
	$ docker image ls
	
	$ docker container run --name some-postgres -e POSTGRES_PASSWORD=mysecretpassword -d postgres
	```
	
	```
	$ docker container exec -it {CONTAINER ID} /bin/bash
	
	root@b0bfc4e4bd54:/# psql -U postgres
	psql (16.3 (Debian 16.3-1.pgdg120+1))
	Type "help" for help.
	
	postgres=#   <- postgres 컨테이너 내부
	```
	
	```
	postgres=# CREATE DATABASE ml;
	CREATE DATABASE
	postgres=# \list
	~~ List of databases ~~
	ml~~
	postgres=# \q
	root@b0bfc4e4bd54:/# exit
	```
	
	```
	$ docker container stop b0bfc4e4bd54
	$ docker container rm b0bfc4e4bd54
	$ docker container run --name some-postgres -e POSTGRES_PASSWORD=mysecretpassword -d postgres
	$ docker container exec -it e19706d69a15 /bin/bash
	root@e19706d69a15:/# psql -U postgres
	postgres=# \list
	ml 없음
	```
	삭제하고 똑같이 다시 만들면 당연히 사라짐
	종료했다가 시작은 사라지지않음
	- 데이터를 어떻게 보관 할수 있을까?
	- ## 도커 볼륨(docker volume)
		- ### 로컬경로와 연결
			```
			$ cd test
			$ pwd
			
			$ docker container run -e POSTGRES_PASSWORD=mysecretpassword -v /home/ubuntu/work/test:/work/test:rw -d postgres
			-v{호스트 경로}:{컨테이너 경로}
			$ docker container ls
			
			$ docker container exec -it {CONTAINER ID} /bin/bash
			/# ls
			/# cd work
			/work# ls
			/work# cd test
			/work/test# ls
			while_loop.py  yaml_exampl.yml
			
			연동이 되어 있어서 안과 밖에서 파일을 생성해도 똑같이 존제한다
			/work/test# mkdir tmp_test
			/work/test# ls
			tmp_test  while_loop.py  yaml_exampl.yml
			/work/test# exit
			
			/work/test$ ls
			tmp_test  while_loop.py  yaml_exampl.yml
			
			# 실습 컨테이너 정리
			$ docker container ls
			$ docker container stop {CONTAINER ID}
			$ docker container rm {CONTAINER ID}
			```
			![](https://i.imgur.com/Iyle1IX.png)
		- ### 도커 볼륨 생성