# 정렬 알고리즘
---
- ## 5-1-5 퀵 정렬(quick sort) ★★★
	- 비교기반 정렬 알고리즘
	- 분할 정복 알고리즘
	- 배열에서 피봇(pivot)이라는 특정 값을 선택
	- ==피봇보다 작은 값으로 구성된 배열과 패봇보다 큰 값으로 구성된 배열로 분할해 정렬==
	- ### 분할하는 과정
		1. 리스트 안에 있는 한 요소를 선택한다. 고른 원소를 **피벗(pivot)** 이라고 한다.
			- 피벗을 선택하는 방법: 일반적으로 리스트의 첫 번째 원소, 마지막 원소, 중간값, 랜덤
		2. 피벗을 기준으로 피벗보다 작은 요소들은 모두 피벗의 왼쪽으로 옮겨지고 큰 요소들은 모두 피벗의 오른쪽으로 옯겨진다
			- 피벗을 중심으로 왼쪽: 피벗보다 작은요소들
			- 피벗을 중심으로 오른쪽: 피벗보다 큰 요소들
		3. 피벗을 제외한 왼쪽 리스트와 오른쪽 리스트를 다시 정렬한다.
			- 분할된 부분 리스트에 대하여 **순환호출** 을 이용하여 정렬을 반복한다.
			- 부분 리스트에서도 다시 피벗을 정하고 피벗을 기준으로 2개의 부분 리스트로 나누는 과정을 반복한다.
		4. 부분 리스트들이 더이상 분할이 불가능할 때까지 반복한다.
			- 리스트의 크기가 0, 1 이 될때까지 반복한다.
		![](https://i.imgur.com/ijJ6QIq.png)
		- 예시 코드
			```
			array = [5, 7, 9, 0, 3, 1, 6, 2, 4, 8]
			print("초기 배열:", array)
			
			
			def quick_sort(array, start, end):
			  if start >= end:
			    return
			
			  pivot = start
			  left = start + 1
			  right = end
			
			  while left <= right:
			    # 디버깅 출력
			    print(" 피벗:", array[pivot], "\n", "low:", array[left], " high:",
			          array[right])
			
			    # 피벗보다 큰 첫 번째 요소 찾기
			    while left <= end and array[left] <= array[pivot]:
			      left += 1
			      if left <= end:  # 범위를 벗어나지 않도록 방지
			        print(" low:", array[left], " high:", array[right])
			
			    # 피벗보다 작은 첫 번째 요소 찾기
			    while right > start and array[right] >= array[pivot]:
			      right -= 1
			      if right > start:  # 범위를 벗어나지 않도록 방지
			        print(" low:", array[left], " high:", array[right])
			
			    # 포인터가 엇갈리지 않았다면, left와 right 위치의 요소를 교환
			    if left <= right:
			      array[left], array[right] = array[right], array[left]
			      print("교환됨:", array)
			    else:
			      # 포인터가 엇갈렸다면, 피벗과 right 위치의 요소를 교환
			      array[pivot], array[right] = array[right], array[pivot]
			      print("피벗 교환됨:", array)
			      print("--------------------------------------------")
			
			  # 분할 이후 왼쪽 부분과 오른쪽 부분에서 각각 정렬 수행
			  quick_sort(array, start, right - 1)
			  quick_sort(array, right + 1, end)
			
			
			quick_sort(array, 0, len(array) - 1)
			print("정렬된 배열:", array)
			```
			- 로그 출력
				![300](https://i.imgur.com/BIW5b3o.png)
	- ### 퀵 정렬 시간복잡도
		- 평균적으로  $O(nlogn)$이다.
		- 최악의 경우 $O(N)$이 될 수 있다.
		- ==피벗으로 어떤 값을 선택하느냐에 따라 퀵 정렬의 성능이 좌우된다.
---
- ## 5-1-6 힙 정렬(heap sort) ★★★
	- 비교 기반 정렬 알고리즘
	- ==최대 힙이나 최소 힙 자료구조를 이용해 정렬==
		- 최대 힙으로 오름차순 정렬
		- 최소 힙으로 내림차순 정렬
	- 힙 정렬 과정에는 크게 배열을 힙으로 만드는 힙 생성 알고리즘 과정과 힙에서 요소를 꺼내 정렬하는 과정으로 나눈다
	- **힙 생성 알고리즘(heapify)**
		- 특정 노드의 두 자식 노드 중 우선순위가 높은 자식 노드와 위치를 교환하는 방식
		- ==배열을 힙으로 만드는 과정을 수행==
			- 배열을 오름차순으로 힙 정렬 하기 위해 최대힙을 구성
			- 예를들어 [7, 4, 5, 6, 3, 1, 2]의 배열이 있다
			- 노드 4보다 자식노드 6의 우선순위가 더 높으므로 위치를 교환한다.
			![400](https://i.imgur.com/RrUcCmv.png)  _힙 정렬 예 - 최대 힙 구성_
			- ==최대 힙에서 삭제 연산을 이용해 정렬을 수행==
			- 삭제 연산으로 꺼낸 루트 노드의 값을 힙의 마지막 노드가 있던 자리로 이동
			- 노드 갯수만큼 반복하면 정렬 완료
			![450](https://i.imgur.com/SM3EYyU.png)
			![450](https://i.imgur.com/shY0jsC.png)
			- 삭제연산 수행
				1. 루트 노드를 꺼낸다
				2. 마지막 노드를 루트노드 위치로 이동
				3. 루트 노드를 마지막 노드 위치의 배열과 위치 교환후 힙에서 제외
				4. 위 과정을 전부 반복
				5. 정렬 완료
	- ### 시간 복잡도
		- ==힙 정렬을 수행하면== $O(nlogn)$
		- 힙 생성 알고리즘을 수행하는데  $O(log n)$
		- 전체 요소가 $n$개여서 전체 정렬 하는데 $O(n log n)$이 걸린다.
---
- ## 5-1-7 기수 정렬(radix sort) ★
	- 비교하지 않는 정렬 알고리즘
	- ==낮은 자릿수 부터 정렬을 수행==
	- 십진수에서 각 자리수에 0~9까지 숫자별로 **버킷(bucket)** 이라는 큐를 생성한다.
	- 정렬하려는 숫자들의 각 자리수에 해당하는 숫자를 각각 버킷에 넣어 정렬하고 자릿수만큼 반복
		- 버킷 구성![](https://i.imgur.com/qNBMKHr.png)
		- 일의 자릿수 기준으로 순서대로 버킷에 넣는다![](https://i.imgur.com/Qx0KkWr.png)
		- 버킷에서 숫자들을 꺼내 배열에 넣는다![](https://i.imgur.com/cOdRKz6.png)
		- 십의 자릿수 기준으로 다시 버킷에 넣는다![](https://i.imgur.com/aFPts0m.png)
		- 버킷에서 숫자들을 꺼내 배열에 넣는다![](https://i.imgur.com/ptwF3hk.png)
	- ### 시간 복잡도
		- 데이터 개수는 $n$, 최대 자릿수를 $d$라고 할때 $O(dn)$으로 빠른 편에 속한다.
---
- ## 5-1-8 계수 정렬(counting sort) ★
	- 비교하지 않는 정렬 알고리즘
	- ==데이터의 개수를 세서 정렬하는 방식==
	- 정렬 하려는 데이터의 범위를 인덱스로 갖는 빈 배열 생성
		- 데이터 범위가 0~99까지라면 크기가 100인 빈 배열 생성
	- 정렬하려는 배열을 순회 하면서 데이터에 해당 인덱스의 값을 1씩 증가시킨다.
	- ### 제약 조건
		- 데이터의 범위가 0 또는 양의 정수여야 한다.
	 ![400](https://i.imgur.com/nZci340.png)  _계수 정렬 예_
	 - ### 시간복잡도
		 - 데이터의 개수를 $n$, 데이터의 최댓값을 $k$라고 할 때 $O(n+k)$가 된다.
		 - 데이터의 최댓값이 무대한에 수렴하면 시간복잡도 역시 무한으로 수렴한다.
		 - 데이터 범위만한 크기의 배열을 생성해야 하므로 사용하는 메모리 공간이 있다는점을 주의해야 한다.
---
- TMI
	- Python의 sorted()는 Timsort 알고리즘 사용
	- Timsort 알고리즘이란?
		- Insert sort와 Merge sort를 결합하여 만든 Hybrid stable sorting 알고리즘이다.
		- 시간복잡도(최선 : $O(n)$, 평균: $O(nlogn), 최악: $O(nlogn)$)