- ### 웹 서버란?
	- 클라이언트 서버 구조
		- html, CSSS, js
		- 화면을 보여주는것은 클라이언트 (크롬, 엣지, 파이어폭스 등...)
		- 클라이언트 -페이지에 대한 요청-> 서버 -응답-> 클라이언트
	- 웹 서버의 개념
		- 서버란?
			- 클라이언트가 요청한 서비스를 제공해주는 프로그램
			- 서버가 어떤 서비스를 제공하느냐에 따라 종류가 나뉨
		- 서버의 종류
			- 웹 서버, 메일 서버, 데이터베이스 서버, 프록시 서버
		- 웹 서버란?
			- 웹 브라우저와 같은 클라이언트로부터 HTTP요청을 받아들이고 HTML 문서와 같은 웹 페이지를 반환하는 컴퓨터 프로그램
			- 위에 언급한 기능을 제공하는 컴퓨터 프로그램을 실행하는 컴퓨터
		- http 
			- HTTP : 웹 상에서 데이터를 전달할 때 사용하는 프로토콜
			- Protocol : 웹 상에서 데이터를 주고 받을 때 지켜야 하는 규칙
				- 동일한 프로토콜을 사용 해야한다
			- https는 http에 **보안 기능**을 추가한 것
				- SSL(Secure Socket Layer)
	- API의 개념
		- 애플리케이션 프로그래밍 인터페이스 (Application Programming Interface)
		- 컴퓨터나 컴퓨터 프로그램 사이의 연결을 의미
		- 사용자 -요청-> 점원 -> 주방장 -> 점원 -응답-> 사용자
			- 점원 = API, 주방장 = 서버
- ### 웹 서버의 기본 구조
	![[Pasted image 20240514113648.png]]
	![[Pasted image 20240514114229.png]]
	- 시간이 지나면 DB가 커지기 때문에 서버와 분리
	- 동적 페이지 : 접속하는 유저에 따라서 다르게 출력될 경우? (네이버...)
		- 광고, 추천, 유튜브 같은건 모두 동적, 요즘은 거의다 동적 페이지
	- 정적 페이지 : 항상 똑같은 페이지 (날씨 페이지...)
		- APACHE
			- 프로세스/스레드 기반 구조
			- 사용자의 HTTP 요청이 올때마다 프로세스 생성
			- 사용자의 요청이 많아지면 -> 프로세스 생성으로 인한 메모리 부족, CPU 과부화
			- 커넥션이 1만개가 넘어가면 하드웨어 성능에 상관없이 더이상 커넥션을 못하는 C10K 문제 발생
		- NGINX
			- 비동기 이벤트 기반 구조
			- 이벤트 : 커넥션 생성, 제거, 새로운 요청 처리
			- 많은 요청이 들어와도 비동기 방식으로 대기시켜서 먼저 등록된 요청부터 처리해주는 방식
			- 예전에는 아파치를 자주 사용했지만 요즘은 Nginx를 더 많이 사용하는 추세
	- WSGI (Web Server Gateway Interface)
		- 웹서버는 파이썬을 모름, gunicorn은 웹 서버가 받아들인 요청을 플라스크에게 전달해주는 역할
		- 종류 : gunicorn, uwsgi
	- 웹 애플리케이션 서버란?
		- 동적 페이지를 처리하는 서버
		- 동적 페이지는 데이터베이스와 연결되어 필요한 데이터를 주고 받는다.
		- 종류 : Django(파이썬), Flask(파이썬), Ruby on Rails(루비), Spring(자바)
- ### 플라스크 API 서버 구축
	```
	conda activate yeardream
	
	pip install scikit-learn
	pip install flask
	pip install gunicorn
	pip install psycopg2-binary
		
	jupyter notebook
	```
	New -> notebook -> Python3 (ipykernel) -> from flask import Flask
	```
	from flask import Flask
	
	app = Flask(__name__) # 플라스크 애플리케이션 인스턴스 생성
	
	#L7 로드밸런서
	@app.route('/') # 라우팅, 루트 주소(/)로 접근했을 때 다음 함수 return값이 브라우저에 나타남
	
	def welcome():
	    return 'HELLO, ML API SERVER'
	
	if __name__ == '__main__': # 파이썬을 실행했을 때 아래 코드로 실행
	    app.run(host='127.0.0.1', port=5001)
	```
	
	```
	(base) a-35@A-35ui-iMac ~ % curl http://127.0.0.1:5001
	
	HELLO, ML API SERVER
	```
	
	- 머신러닝 기능 추가
	```
	import numpy as np
	from sklearn.linear_model import LinearRegression
	
	from flask import Flask, request, jsonify
	
	app = Flask(__name__)
	
	np.random.seed(0)
	X = np.random.rand(10, 1)
	y = 2 * X + 1 + 0.1 * np.random.randn(10, 1)
	
	model = LinearRegression()
	model.fit(X, y)
	
	@app.route('/')
	def welcome():
	    return 'HELLO, ML API SERVER'
	
	@app.route('/predict', methods=['POST'])
	def predict():
	    data = request.json
	    new_X = data['input']
	    y_pred = model.predict(np.array(float(new_X[0])).reshape(1, -1))
	    res = jsonify({'predicted_output': y_pred.tolist()})
	    return res
	    
	if __name__ == '__main__':
	    app.run(host='127.0.0.1', port=5001)
	```
	
	```
	# 맥북
	curl -d '{"input":["0.8"]}' -H "Content-Type: application/json" -X POST http://localhost:5001/predict
	
	# 윈도우
	curl -d "{""input"":[""0.8""]}" -H "Content-Type: application/json" -X POST http://localhost:5001/predict
	```
	
	- AWS ec2에서 플라스크 서버 생성
	```
	~/work$ vim test01.py
	
	import numpy as np
	from sklearn.linear_model import LinearRegression
	
	from flask import Flask, request, jsonify
	
	app = Flask(__name__)
	
	np.random.seed(0)
	X = np.random.rand(10, 1)
	y = 2 * X + 1 + 0.1 * np.random.randn(10, 1)
	
	model = LinearRegression()
	model.fit(X, y)
	
	@app.route('/')
	def welcome():
	    return 'HELLO, ML API SERVER'
	
	@app.route('/predict', methods=['POST'])
	def predict():
	    data = request.json
	    new_X = data['input']
	    y_pred = model.predict(np.array(float(new_X[0])).reshape(1, -1))
	    res = jsonify({'predicted_output': y_pred.tolist()})
	    return res
	    
	if __name__ == '__main__':
	    app.run(host='0.0.0.0', port=5000)
	```
	
	```
	pyenv activate py3_11_9
	python test01.py
	```
- ### nginx
	```
	# 설치
	sudo apt install nginx
	
	# 설치 확인
	sudo systemctl status nginx
	```
- ### 머신러닝 서버 구축
	- gunicorn을 사용해 Flask 애플리테이션 실행
		- gunicorn : nginx와 Flask를 연결시켜주는 역할
	```
	# gunicorn 과 flask 를 연결
	gunicorn test01:app --bind 0.0.0.0:5000
	```
	- test01 : Flask 애플리케이션을 포함하는 파이썬 파일 이름
	- app : Flask 애플리테이션 객체 변수 이름
	- --bind : 바인딩 : 네트워크 엔드포인트에서 통신 준비
	- 0.0.0.0 : 모든 IP 주소 수신
	- 5000 : 포트 5000에서 애플리케이션 실행
	```
	# NGINX 파일 수정
	sudo vim /etc/nginx/sites-enabled/default
	
	location / {
	
	# First attempt to serve request as file, then
	
	# as directory, then fall back to displaying a 404.
	
	# 주석 처리(파일 또는 디렉토리가 존재하지 않으면 404 오류 반환)
	#try_files_files $uri $uri/ =404;
	
	# 코드 추가(nginx에서 받은 HTTP 요청을 해당 IP:Port로 전달)
	proxy_pass http://127.0.0.1:5000;
	
	# NGINX 재시작
	sudo systemctl restart nginx
	sudo systemctl status nginx
	```
	
	```
	# gunicorn 백그라운드로 실행
	nohup gunicorn test01:app --bind 0.0.0.0:5000 >& /dev/null &
	
	# 종료
	ps -ef | grep test01
	
	ubuntu      8008    5406  0 06:40 pts/0    00:00:00 /home/ubuntu/.pyenv/versions/3.11.9/envs/py3_11_9/bin/python /home/ubuntu/.pyenv/versions/py3_11_9/bin/gunicorn test01:app --bind 0.0.0.0:5000
	ubuntu      8130    8008  1 06:45 pts/0    00:00:00 /home/ubuntu/.pyenv/versions/3.11.9/envs/py3_11_9/bin/python /home/ubuntu/.pyenv/versions/py3_11_9/bin/gunicorn test01:app --bind 0.0.0.0:5000
	ubuntu      8134    5406  0 06:45 pts/0    00:00:00 grep --color=auto test01
	
	kill -9 8008 8130
	```
	
	nginx(80 Port) -> gunicorn -> flask(5000 Port)
		nginx를 연결 전에는 퍼블릭IPv4:5000 (flask)으로 접속
		nginx 연결후 퍼블릭IPv4만 입력해도 접속 가능,  퍼블릭IPv4:80 도 가능
	![[991B5BCB-1D69-4D40-B11B-6999EE2DA9DB.png]]