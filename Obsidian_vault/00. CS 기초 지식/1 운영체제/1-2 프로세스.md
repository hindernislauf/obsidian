# 1-2 프로세스
- ## 1-2-1 프로세스와 스레드 ★★★
	- ### 프로세스
		- 컴퓨터에서 실행 중인 하나의 프로그램을 의미한다.
		- 프로그램은 특정 작업을 수행하기 위한 명령어의 집합이다.
		- OS는 프로그램을 실행하면서 디스크에 저장된 데이터를 메모리로 로드한다.
		- 프로세스는 OS로부터 독립된 메모리 영역(코드, 데이터, 스택, 힙)을 할당 받으며, 다른 프로세스의 메모리 영역에 접근할수 없다.
		![400](https://i.imgur.com/6mvHszI.png)  _프로세스에 할당된 메모리 영역_
	- ### 프로세스의 메모리 영역 구조
		![400](https://i.imgur.com/CwBB8SX.png) _프로세스의 메모리 영역 구조_
		- **스택(stack)**: 지역 변수, 함수의 매개변수(parameter), 반환되는 주소 값 등이 저장되는 영역
		    - 높은 주소 값에서 낮은 주소 값으로 메모리 할당
		    - 영역 크기는 컴파일 때 결정
		- **힙(heap)**: 사용자에 의해 동적 메모리 할당이 일어나는 영역
		    - C 언어에서 <a href="https://wikidocs.net/166082">`malloc()`</a>으로 할당되는 영역
		    - 낮은 주소 값에서 높은 주소 값으로 메모리 할당
		    - 영역 크기는 런타임 때 결정
		- **데이터(data)**: 전역 변수, 정적 변수, 배열, 구조체 등이 저장되는 영역
		    - 세부적으로 `BBS(Block Stated Symbol) 영역`과 `데이터 영역`으로 다시 나뉨
		        - BBS 영역은 초기화하지 않은 변수를, 데이터 영역은 초기화한 변수를 저장
		- **코드(code)**: 실행할 코드가 기계어로 컴파일되어 저장되는 영역
		    - `텍스트(text) 영역`이라고도 함
		- 스택 영역과 힙 영역은 동적 메모리 할당이 가능하여 두 영역 사이에 빈 메모리 공간 존재
		- **스택 영역**: LIFO(Last In First Out, 후입선출) 방식, 높은 주소 값 → 낮은 주소 값 순서 사용    
		- **힙 영역**: FIFO(First In First Out, 선입선출) 방식, 낮은 주소 값 → 높은 주소 값 순서 사용    
		- 메모리 영역을 공유하므로, 상호 영역 침범 문제 발생 가능
		    - **스택 오버플로(stack overflow)**: 스택 영역이 힙 영역을 침범하는 경우
		    - **힙 오버플로(heap overflow)**: 힙 영역이 스택 영역을 침범하는 경우
		- **오버플로(overflow)**: 메모리 공간에서 할당할 수 있는 최대 범위를 넘어가는 것을 의미    
		- **언더플로(underflow)**: 메모리 공간에서 할당할 수 있는 최소 범위보다 작은 것을 의미
	- ### 스레드(thread)
		- 프로세스에서 실제로 실행되는 흐름의 단위
		- 프로세스 내 존재 → 프로세스의 메모리 공간 이용, 지역 변수를 저장하는 스택 영역을 할당 받음 / 전역 변수를 저장하는 힙 영역은 다른 스레드와 공유

		  ![400](https://i.imgur.com/kIoOhPJ.png) _운영체제에서 프로세스와 스레드의 구조_
----
- ## 1-2. 2 PCB ★★
	(Process Control Block, 프로세스 제어 블록)
	- ==OS에서 프로세스를 제어하기 위해 저장한 프로세스 정보==
	- 프로세스 현재 상태, PID(Process ID), 부모 프로세스 PID, 자식 프로세스 PID, PC(Program Counter, 다음 실행 명령어 주소), 프로세스 우선순위, 메모리 제한 등 **프로세스의 모든 정보를 저장하고 있는 자료구조** 
	- 프로세스가 상태 전이를 할경우 PCB를 이용
		- 프로세스가 running -> ready상태로 전이되기 직전, PCB에 프로세스의 모든 정보를 저장한 후 상태 전이를 한다.
		- ready -> running상태로 전이되기 직전 저장된 PCB에서 이전 상태 값을  모두 복귀 시킨후 상태 전이를 한다.
		- 이것을 Context Switching 이라고 한다.
	- ### PCB의 구조
		![300](https://i.imgur.com/gQjBmPr.png) _PCB의 구조_
		![](https://i.imgur.com/7R6OUbv.png)
		- #### 포인터
			- 프로세스의 현재 위치를 저장하는 포인터 정보
		- #### 프로세스 상태
			- 프로세스의 상태 (생성, 준비, 실행, 대기, 종료) 에 대한 정보를 저장
		- #### 프로세스 식별자
			- 모든 프로세스에는 각 프로세스를 식별하는 고유한 ID, PID 가 할당
		- #### 프로그램 계수기
			- 프로세스가 실행해야 하는 다음 명령어의 주소
		- #### 레지스터
			- 누산기, 베이스, 레지스터 및 범용 레지스터를 포함하는 CPU 레지스터에 있는 정보
		- #### 메모리 제한
			- 운영 체제에서 사용하는 메모리 관리 시스템에 대한 정보가 포함
			- 페이지 테이블, 세그먼트 테이블 등이 포함될 수 있음
---
- ## 1-2-3 프로세스의 생성 ★★★
	- 새로운 프로세스: 기존 프로세스에서 `fork()` 함수를 호출하여 생성
	- `fork()` 함수
	    - 함수를 호출한 프로세스 복사 기능 존재
	        - 기존 프로세스: 부모 프로세스(parent process)
	        - 복사된 프로세스: 자식 프로세스(child process)
	    - 부모 프로세스에서 `fork()` 함수 호출 시,
	        - 부모 프로세스: 자식 프로세스의 PID 값 반환
	        - 자식 프로세스: 0을 반환
           
		    ![400](https://i.imgur.com/wZLlEFH.png)  _자식 프로세스의 생성_

	- ### 프로세스 종료
		- #### 운영체제가 프로세스를 종료하는 경우
		    - 프로세스가 운영체제의 종료 함수(`exit()`)를 호출해 정상 종료하는 경우
		    - 프로세스의 실행 시간 또는 특정 이벤트 발생을 기다리는 시간이 제한된 시간을 초과한 경우
		    - 프로세스가 파일 검색 또는 입출력에 실패하는 경우
		    - 오류 발생 또는 메모리 부족 등이 발생하는 경우
		- #### 부모 프로세스가 자식 프로세스를 종료시키는 경우
		    - 자식 프로세스가 할당된 자원을 초과해 사용할 때
		    - 자식 프로세스에 할당된 작업이 없을 때
---
- ## 1-2-4 프로세스 상태도 ★★★
	- ### 프로세스 상태도
		![400](https://i.imgur.com/GhZ4MXl.png)  _프로세스 상태도_

		- **생성(new)**: 프로세스가 PCB를 가지고 있지만 OS로부터 승인(admit) 받기 전
			- 승인(admit): CPU를 제외한 다른 자원이 준비되어 해당 프로세스가 준비 상태가 될 수 있도록 OS가 허락하는것을 의미
		- **준비(ready)**: OS로부터 승인받은 후 준비 큐에서 CPU 할당을 기다림
		- **실행(running)**: 프로세스가 CPU를 할당받아 실행함
		- **대기(waiting)**: 프로세스가 입출력이나 이벤트 발생을 기다려야 해서 CPU 사용을 멈추고 기다림
		- **종료(terminated)**: 프로세스 실행을 종료함
		
	- #### 프로세스는 한 상태에서 다른 상태로 아래와 같이 변화한다
		- 생성 → 준비: 생성 상태의 프로세스가 OS로부터 승인을 받아, 준비 상태의 프로세스가 모여 있는 자료구조인 준비 큐(ready queue)에 추가됨
		- 준비 → 실행: 준비 큐에 있는 프로세스 중 우선순위가 높은 프로세스가 디스패치(dispatch)되어 실행됨
			- 디스패치(dispatch): 프로세스에 CPU 자원을 할당해 해당 프로세스가 준비 상태에서 실행상태가 되는것을 의미.
		- 실행 → 준비: CPU 독점을 방지하기 위해 타임아웃(timeout)되어 준비 상태로 변경됨
		- 실행 → 대기: 입출력 또는 이벤트 때문에 대기 상태로 변경됨
		- 대기 → 준비: 입출력 또는 이벤트가 완료되어 준비 상태로 변경됨
		- 실행 → 종료: 실행 중인 프로세스가 정상적으로 끝나서 종료 상태로 변경됨
---
- ## 1-2-5 멀티 프로세스와 멀티 스레드 ★★★
	- **동시성(concurrency)**: ==하나의 코어(싱글 코어)에서 여러 작업을 번갈아 가면서 처리하는 방식==
		- **콘텍스트 스위칭(context switching)**: 하나의 CPU에서 여러 작업을 번갈아 가면서 처리하기 위해 처리 중인 작업을 교체하는 것
	- **병렬성(parallelism)**: ==CPU가 여러 개(멀티 코어) 있어서 각 CPU에서 각 작업을 동시에 처리하는 방식, 물리적인 시간 관점에서 동시에 여러 작업이 처리됨==
	![400](https://i.imgur.com/DloKOln.png)  _동시성과 병렬성_
	- ### 멀티 프로세스
		- **멀티 프로세스(multi process)**: 응용 프로그램 하나를 여러 프로세스로 구성하는 것
		    - 멀티 프로세스 환경에서는 한 프로세스가 죽어도 다른 프로세스에 영향을 주지 않음
		    - ==응용 프로그램을 프로세스 하나로 구성하는 것보다 여러 개로 구성하는 것이 안정적==
		    - 단점: ==시간과 메모리 공간을 많이 사용==
		- **오버헤드(overhead)**: CPU에서 기존에 처리하던 프로세스가 할당받은 메모리 영역을 다른 프로세스에서 사용할 수 있게 교체할때 필요한 시간과 메모리를 의미
		- **IPC(Inter Process Communication)**: 프로세스들 사이에 서로 데이터를 주고받는 행위 또는 그에 대한 방법이나 경로를 뜻한다.
		![400](https://i.imgur.com/c9gd6Mu.png)  _멀티 프로세스 구조_
		
	- ### 멀티 스레드
		- **멀티 스레드(multi thread)**: 스레드를 여러 개 생성해 스레드들이 각자 다른 작업을 처리하는 것
		    - 스레드 간에 힙, 데이터, 코드 영역 공유 → context switching 간에 오버헤드가 적게 발생, IPC 불필요 → 멀티 프로세스 단점 보완
		    - 자원 효율성: 다중 프로세스 생성 < 다중 스레드 생성
		    - 시스템 처리 비용: 스레드 간 자원 공유 < 프로세스 간 자원 공유
		    - 프로그램 응답 시간: 스레드 간 < 프로세스 간
		    - 단점
		        - 공유 자원에 대한 동기화 필수
		        - 스레드에 문제가 생기면 프로세스 내 다른 스레드에 영향 
		![300](https://i.imgur.com/0BjdmcS.png)  _멀티 스레드 구조_

---
- ## 1-2-6 콘텍스트 스위칭 ★★★
	- **인터럽트(interrupt)**: CPU가 프로세스 처리 중에 입출력 관련 이벤트가 발생하거나 예외 상황이 발생할 때 이에 대응할 수 있게 CPU에 처리를 요청하는 것
	    - 발생 상황
	        - ==입출력이 발생할 때==
	        - ==CPU 사용 시간이 만료되었을 때==
	        - ==자식 프로세스를 생성할 때==
	- **컨텍스트(context)**: CPU가 처리하는 프로세스의 정보
	- **컨텍스트 스위칭(context switching)**: ==멀티 프로세스 환경에서 CPU가 처리 중인 프로세스의 정보를 바꾸는 것==
		![400](https://i.imgur.com/krHEPfS.png)  _콘텍스트 스위칭 과정_
		- **오버헤드 발생** (어떤 처리를 하는데 간접적인 처리 시간과 메모리가 소요될 경우)
			- P1의 정보 -> P1의 PCB에 저장 and P2의 PCB에 저장된 정보 -> 레지스터에 로드 하는 동안 CPU는 아무 일도 못하게 된다.
		- 멀티 스레드를 처리 할때도 컨텍스트 스위칭이 이뤄진다.
			- 멀티프로세스의 컨텍스트 스위칭 보다 시간과 메모리 자원을 적게 사용
			- 멀티 스레드는 스택을 제외한 힙, 데이터, 코드 영역을 공유하므로 레지스터에 저장하고 로드해야하는 데이터가 상대적으로 적기 때문이다.
	- PCB에는 프로그램 카운터와 스택 포인터 값이 저장되어 있음 → 이전에 실행하던 코드를 이어서 실행 하능
	    - **프로그램 카운터(PC, Program Counter)**: ==프로세스가 이어서 처리해야 하는 명령어의 주소값==
	    - **스택 포인터(stack pointer)**: ==스택 영역에서 데이터가 채워진 가장 높은 주소 값==
---
- ## 1-2-7 프로세스 동기화 ★★★
	- #### 경쟁 상태
		- ==공유 자원에 동시에 접근해 경쟁하는 상태== → 여러 프로세스 또는 스레드에서 하나의 공유 자원에 접근하는 경우, 자원에 접근 하는 순서에 따라 결과 값이 달라질 수 있음
		![400](https://i.imgur.com/CgF01ZP.png) _경쟁 상태 예_
	- #### 임계 영역
	- ==공유 자원에 접근할 수 있고 접근 순서에 따라 결과가 달라지는 코드 영역==
	- 경쟁 상태를 방지하기 위해 데이터의 일관성이 유지 되도록 **프로세스 동기화**를 해야함
	- 임계 영역에 여러 접근이 동시에 발생하는 것을 방지하기 위한 조건
	    - **상호배제 기법(mutal exclusive)**: 어떤 프로세스가 임계 영역을 실행 중일 때 다른 프로세스가 임계 영역에 접근할 수 없음
	        - 상호배제 기법: 뮤텍스, 세마포어
	    - **진행(progress)**: 임계 영역을 실행 중인 프로세스가 없을 때 다른 프로세스가 임계 영역을 실행
	    - **한정된 대기(bounded waiting)**: 임계 영역에 접근을 요청했을 때 무한한 시간을 기다리지 않음
	- #### 뮤텍스(mutex)
		- ==락(lock)을 가진 프로세스만이 공유 자원에 접근할 수 있게 하는 방법==
		- 임계 영역에 먼저 접근한 프로세스가 임계 영역에 락을 걸면 다른 프로세스들은 해당 프로세스가 락을 해제하기 전까지 대기해야 함    
		- **스핀락(spinlock)**: 락을 얻기 위해 프로세스가 반복문을 돌면서 기다리는 것 → `바쁜 대기`의 일종 → 프로세스 교체 속도 빠름
		- **락킹 매커니즘(locking mechanism)** 이라고도 함
		- `바쁜 대기`: 프로세스가 공유 자원에 접근할 수 있는 권한을 얻을 때까지 확인하는 과정
		![400](https://i.imgur.com/yYFZ5yH.png)  _뮤텍스 예_
	- #### 세마포어(semaphore)
		- ==공유 자원에 접근할 수 있는 프로세스의 수를 정해 접근을 제어하는 방법==
		- **시그널링 메커니즘(signaling mechanism)** 이라고도 함 → 공유 자원에 접근한 프로세스가 접근을 해제하면 다른 프로세스가 접근할 수 있도록 신호를 보냄
		![400](https://i.imgur.com/vBAjksP.png)  _세마포어 예_
	-  *동기와 비동기
		- 동기(synchronization): 여러 작업을 처리할 때 작업 순서를 보장함
		- 비동기(asynchronization): 여러 작업을 처리할 때 작업 순서를 보장하지 않음
	- *블로킹과 넌블로킹
		- 블로킹(blocking): 작업을 수행할 때 대기할 수 있다는 것을 의미, 작업 순서를 보장하지 않음
		- 넌블로킹(non-blocking): 작업을 시작하면 대기 없이 수행한다는 것을 의미함
---
- ## 1-2-8 교착 상태 ★★★
	- 상호배제 기법 때문에 ==2개 이상의 프로세스가 각각 자원을 가지고 있으면서 서로의 자원을 요구하며 기다리는 상태==
	- **교착 상태 발생**의 4가지 필요 충분 조건
	    - 상호배제(mutal exclusion): 하나의 공유 자원에 하나의 프로세스만 접근할 수 있음
	    - 점유와 대기(hold and wait): 프로세스가 최소 하나의 자원을 점유하고 있는 상태에서 추가로 다른 프로세스에서 사용 중인 자원을 점유하기 위해 대기
	    - 비선점(non-preemption): 다른 프로세스에 할당된 자원을 뺏을 수 없음
	    - 환형 대기(circular wait): 프로세스가 자신의 자원을 점유하면서 앞이나 뒤에 있는 프로세스의 자원을 요구
	- **교착 상태를 막는 방법**
	    - 상호배제 부정: 여러 프로세스가 동시에 하나의 공유 자원을 사용할 수 있게 함
	    - 점유와 대기 부정: 프로세스가 실행되기 전에 필요한 모든 자원을 할당함으로써 프로세스 대기를 없앰. 또는 프로세스가 자원을 점유하지 않은 상태에서만 자원을 요구하게 함
	    - 비선점 부정: 자원을 점유한 프로세스가 다른 자원을 요구할 때 점유한 자원을 반납하게 함
	    - 환형 대기 부정: 자원을 선형 순서로 정렬해 고유 번호를 할당, 각 프로세스에서 요구할 수 있는 번호의 방향을 정해 한쪽 방향으로만 자원을 요구하게 함
---
- ## 1-2-9 스레드 안전 ★★
	- 멀티 스레드 환경에서 ==하나의 변수, 함수, 객체에 스레드 여러 개가 동시에 접근해도 문제가 없음을 의미==
	- **스레드 안전을 위한 조건**
	    - 상호배제(mutal exclusive): 공유 자원에 접근해야 할 때 뮤텍스 또는 세마포어와 같은 상호배제 기법을 사용해 접근을 통제해야 함
	    - 원자 연산(atomic operation): 공유 자원에 접근할 때 원자 연산을 이용하거나 원자적으로 정의된 연산을 이용해 연산 도중에 다른 스레드가 접근할 수 없게 함
	        - 원자 연산: `연산했다`와 `연산 안 했다` 두 가지만 존재하는 연산
	    - 재진입성(reentrancy): 특정 함수를 하나의 스레드에서 실행 중일 때 다른 스레드가 해당 함수를 실행해도 각 스레드에 올바른 결과가 나올 수 있게 해야 함
	    - 스레드 지역 저장소(thread local storage): 각 스레드에서만 접근할 수 잇는 저장소를 사용해서 공유되는 자원을 줄여야 함
---
- ## 1-2-10 IPC ★★
	- 프로세스 간에 자원을 공유하는 방식
	- IPC의 종류
	    1. **공유 메모리(shared memory)**
	        - 프로세스 간에 공유 가능한 메모리를 구성해 자원을 공유하는 방식
	        - 여러 프로세스에서 접근할 수 있으므로 동기화 문제 발생 가능
		    ![400](https://i.imgur.com/9bXAx1J.png)_공유 메모리를 이용한 IPC_
	    1. **소켓(socket)**
	        - 네트워크 소켓을 이용하는 프로세스 간 통신으로, 외부 시스템과도 이용할 수 있음
	        - 클라이언트(client)와 서버(server) 구조로 자원을 주고 
			![400](https://i.imgur.com/TOhHPLR.png)  _소켓을 이용한 IPC_
	    2. **세마포어(semaphore)**
	        - 접근하는 프로세스를 제어해 공유 자원을 관리함
	    3. **파이프(pipe)**
	        - FIFO(First In First Out) 형태의 메모리인 파이프를 이용해 프로세스 간 자원을 공유하는 방식
	        - 파이프는 단방향 통신만 지원 → 읽기 또는 쓰기 중 하나만 할 수 있음
	        - 양방향 통신을 하려면 읽기 파이프(read pipe)와 쓰기 파이프(write pipe)를 각각 생성해야 함
	        ![400](https://i.imgur.com/CoPaOrZ.png)  _파이프를 이용한 IPC_
	    1. **메시지 큐(message queue)**
	        - FIFO 형태의 큐 자료구조를 사용해 프로세스 간 메시지를 주고받는 방식
	        ![400](https://i.imgur.com/vgpHHoo.png)  _메시지 큐를 이용한 IPC_
---
- ## 1-2-11 좀비프로세스와 고아 프로세스 ★★
	- **좀비 프로세스(zombie process)**: 자식 프로세스가 종료되었지만 ==부모 프로세스가 자식 프로세스의 종료 상태를 회수하지 않았을 경우에 남겨진 자식 프로세스
	    - 자식 프로세스가 종료될 때 부모 프로세스에 `SIGCHLD`라는 시그널을 보내면 부모 프로세스에서 `wait()` 함수(시스템 콜)를 호출해 자식 프로세스의 상태 정보를 받고 자원 회수 → 자원 회수 실패 시 좀비 프로세스 발생 → 좀비 프로세스가 쌓이면 자원 낭비 초래
	- **고아 프로세스(orphan process)**: ==부모 프로세스가 자식 프로세스보다 먼저 종료되는 경우의 자식 프로세스==
	    - 고아 프로세스 발생 시
	        - 자식 프로세스의 부모 PID를 init 프로세스의 PID인 1로 바꿔줌 → 고아 프로세스의 부모 프로세스는 init 프로세스가 됨 → 고아 프로세스 작업 종료 시 init 프로세스가 고아 프로세스의 자원 회수 → 좀비 프로세스가 되는 것을 방지
---
