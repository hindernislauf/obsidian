# 06 데이터 변환하기

# **Append-only 데이터 모델링**

- 추가 전용 데이터 = 삽입 전용 데이터
- 데이터베이스 설계 및 데이터 저장에서 사용되는 접근 방식 중 하나
- 데이터가 추가될 수는 있지만 기존 데이터는 수정되거나 삭제될 수 없는 구조
- 이 접근법은 데이터의 무결성과 변경 이력을 유지하는 데 유리한 특성을 가지고 있음
- **완전히 새로 고침된 데이터 모델링**(Fully Refresh Data Modeling)과 유사
    - **완전히 새로 고침된 데이터 모델링**(Fully Refresh Data Modeling)
        
        기존의 데이터 모델이나 구조를 완전히 새로운 방식으로 재설계하거나 교체하는 접근 방식을 말합니다. 이는 데이터베이스 설계나 데이터 저장 및 처리 방법에서 근본적인 변화를 도입하는 것을 의미합니다.
        
        이 접근법은 기존의 데이터 모델이 비효율적이거나, 데이터의 요구 사항이 변경되었거나, 최신 기술 및 요구 사항에 맞추기 위해 데이터 모델을 전면적으로 수정해야 할 때 사용됩니다.
        
        ### 주요 개념
        
        1. **근본적 재설계 (Fundamental Redesign)**:
            - 기존 데이터 모델의 모든 요소를 분석하고, 새로운 요구 사항에 맞추어 모델을 재설계합니다. 이는 테이블 구조, 관계, 인덱스, 데이터 형식 등 모든 측면을 포함할 수 있습니다.
        2. **데이터 이관 (Data Migration)**:
            - 새로운 데이터 모델로의 전환 과정에서 기존 데이터를 새로운 모델에 맞게 변환하여 이관합니다. 이 과정에서는 데이터의 무결성을 유지하고, 손실 없이 이관하는 것이 중요합니다.
        3. **기술적 변화 (Technological Change)**:
            - 새로운 데이터베이스 기술이나 플랫폼을 도입하는 경우, 데이터 모델을 완전히 새로 고쳐야 할 수 있습니다. 예를 들어, 관계형 데이터베이스에서 NoSQL 데이터베이스로 전환하는 경우가 해당됩니다.
        4. **성능 개선 (Performance Improvement)**:
            - 기존 모델의 성능 문제가 발생할 경우, 새로운 데이터 모델링을 통해 성능을 개선합니다. 이는 데이터 저장 방식, 인덱싱 전략, 쿼리 최적화 등을 포함할 수 있습니다.
        
        ### 예시
        
        1. **관계형 데이터베이스에서 NoSQL로의 전환**:
            - 기존의 관계형 데이터베이스 모델이 성능 문제를 겪거나, 비정형 데이터가 많이 포함된 경우, NoSQL 데이터베이스를 도입하여 데이터 모델을 전면적으로 새로 고칠 수 있습니다. 예를 들어, MongoDB나 Cassandra와 같은 NoSQL 데이터베이스를 사용할 수 있습니다.
        2. **기존의 스타 스키마에서 스노우플레이크 스키마로의 전환**:
            - 데이터 웨어하우스에서 기존의 스타 스키마를 스노우플레이크 스키마로 변경하여 데이터 중복을 줄이고 정규화 수준을 높이는 경우입니다.
        3. **데이터베이스 업그레이드**:
            - 데이터베이스 버전 업그레이드와 함께 데이터 모델을 새로 설계하여 새로운 기능이나 최적화된 성능을 활용하는 경우입니다.
        
        ### 단계별 접근법
        
        1. **요구 사항 분석**:
            - 새로운 데이터 모델이 해결해야 할 문제와 요구 사항을 정의합니다.
        2. **기존 모델 평가**:
            - 기존 데이터 모델의 문제점과 개선점을 분석합니다.
        3. **새 데이터 모델 설계**:
            - 요구 사항에 맞추어 새로운 데이터 모델을 설계합니다. 이 과정에서 데이터 구조, 관계, 인덱스, 쿼리 패턴 등을 고려합니다.
        4. **데이터 변환 및 이관 계획**:
            - 기존 데이터를 새로운 모델에 맞게 변환하고, 이관할 계획을 수립합니다.
        5. **테스트 및 검증**:
            - 새로운 데이터 모델을 테스트하고 검증하여 데이터 무결성과 성능을 확인합니다.
        6. **배포 및 모니터링**:
            - 새로운 데이터 모델을 배포하고, 성능 및 안정성을 모니터링하여 필요한 조정을 합니다.
        
        ### 장점
        
        1. **효율성 향상**:
            - 새로운 데이터 모델은 데이터 처리와 쿼리 성능을 개선할 수 있습니다.
        2. **기술적 진화**:
            - 최신 기술과 도구를 활용하여 데이터 관리와 분석의 효율성을 높일 수 있습니다.
        3. **유연성 증가**:
            - 데이터 모델의 유연성을 높여 새로운 요구 사항이나 비즈니스 변화에 빠르게 대응할 수 있습니다.
        
        ### 단점
        
        1. **복잡한 데이터 이관**:
            - 기존 데이터를 새로운 모델로 이관하는 과정에서 데이터 손실이나 변형의 위험이 있습니다.
        2. **비용 및 시간 소요**:
            - 완전히 새로 고치는 과정은 시간과 비용이 많이 소요될 수 있습니다.
        3. **사용자 교육**:
            - 새로운 데이터 모델에 맞추어 사용자와 개발자에게 교육이 필요할 수 있습니다.
        
        **완전히 새로 고침된 데이터 모델링**은 데이터베이스 설계와 관리의 중요한 부분으로, 비즈니스 요구와 기술 변화에 적절히 대응하기 위한 강력한 접근법입니다.
        
    - 유사점과 차이점
        
        ### 유사점
        
        1. **데이터의 변경 이력 유지**:
            - 두 접근법 모두 데이터의 이력을 추적하거나, 데이터의 변동 사항을 관리하는 데 중점을 둡니다.
            - **추가 전용 데이터 모델링**에서는 데이터의 변경 사항을 새로운 레코드로 기록하므로, 변경 이력을 유지할 수 있습니다.
            - **완전히 새로 고친 데이터 모델링**에서는 기존 데이터 모델을 새롭게 설계하여 이력 관리와 같은 요구사항을 충족할 수 있습니다.
        2. **데이터 무결성 유지**:
            - **추가 전용 데이터 모델링**은 데이터를 수정하지 않고 새로운 레코드를 추가하여 데이터의 무결성을 유지합니다.
            - **완전히 새로 고친 데이터 모델링**에서는 새 모델 설계 시 데이터 무결성을 고려하여 설계하며, 데이터 이관 시 무결성을 유지하기 위해 많은 주의를 기울입니다.
        3. **기술적 변화 대응**:
            - 두 접근법 모두 기술적 요구나 비즈니스 요구에 따라 데이터 모델을 조정할 수 있습니다.
            - **추가 전용 데이터 모델링**은 기존 시스템의 구조를 변경하지 않고도 데이터 관리 방식을 개선할 수 있습니다.
            - **완전히 새로 고친 데이터 모델링**은 기술적 변화나 성능 문제를 해결하기 위해 데이터 모델을 새로 설계합니다.
        
        ### 차이점
        
        1. **기본 접근법**:
            - **추가 전용 데이터 모델링**은 데이터가 변경될 때마다 새로운 레코드를 추가하여 이력을 기록합니다. 기존 데이터는 변경되지 않고, 모든 변화가 새로운 레코드로 남습니다.
            - **완전히 새로 고친 데이터 모델링**은 기존 데이터 모델을 전면적으로 재설계하여 새로운 데이터 모델로 대체하는 접근입니다. 기존 모델의 문제를 해결하거나 새로운 요구 사항을 반영하기 위해 데이터 구조를 새롭게 설계합니다.
        2. **데이터 관리 방법**:
            - **추가 전용 데이터 모델링**은 데이터의 변경을 새로운 레코드로 추가하기 때문에 데이터베이스의 용량이 계속 증가합니다. 데이터의 이력과 변경 사항을 추적하는 데 적합합니다.
            - **완전히 새로 고친 데이터 모델링**은 데이터 구조를 완전히 새로 설계하므로, 데이터의 이력 관리 방식이 변경될 수 있습니다. 기존 데이터를 새로운 모델로 이관하는 과정이 포함됩니다.
        3. **적용 사례**:
            - **추가 전용 데이터 모델링**은 로그 기록 시스템, 트랜잭션 로그, 변경 이력 추적 등에서 유용합니다.
            - **완전히 새로 고친 데이터 모델링**은 시스템의 성능 개선, 기술 변화에 대응, 데이터 구조의 근본적인 개선이 필요한 경우에 적합합니다.

### 주요 개념

1. **불변성 (Immutability)**:
    - 데이터는 한 번 저장되면 변경되지 않습니다. 새 데이터를 추가할 때는 항상 기존 데이터와 별도로 새로운 레코드가 생성됩니다.
    - 데이터의 수정이나 삭제가 아닌, 데이터를 추가하는 방식으로만 작업합니다.
2. **데이터 이력 (Data History)**:
    - 모든 변경 사항이 데이터베이스에 기록되므로, 시간이 지남에 따라 데이터의 변경 이력을 추적할 수 있습니다.
    - 과거의 데이터 상태를 조회하거나 분석할 수 있는 기능을 제공합니다.
3. **추적 가능성 (Auditability)**:
    - 모든 데이터 추가 작업이 기록되므로, 데이터의 출처와 변경 이력을 검토할 수 있습니다. 이는 감사와 법적 요구사항 준수에 유용합니다.
4. **스냅샷 (Snapshot)**:
    - 데이터베이스의 특정 시점의 스냅샷을 저장하여 나중에 해당 시점의 상태를 재구성할 수 있습니다.

### 예시

- **로그 파일**:
로그 파일은 일반적으로 append-only 형식을 따릅니다. 로그 파일에 새로운 로그 항목이 추가되면 기존 로그 항목은 변경되지 않으며, 새로운 항목이 파일의 끝에 추가됩니다.
- **트랜잭션 로그**:
금융 시스템이나 데이터베이스 관리 시스템에서는 트랜잭션 로그가 append-only 방식으로 기록됩니다. 트랜잭션 로그는 모든 데이터베이스 변경 사항을 기록하며, 이를 통해 시스템 장애 후 복구가 가능합니다.

### 구현 방법

1. **테이블 설계**:
    - 테이블 구조에 `created_at` 또는 `timestamp`와 같은 필드를 추가하여 데이터가 언제 생성되었는지를 기록합니다.
    - 예를 들어, `user_activity` 테이블을 아래와 같이 설계할 수 있습니다:
        
        ```sql
        CREATE TABLE user_activity (
            id SERIAL PRIMARY KEY,
            user_id INT,
            action VARCHAR(255),
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        );
        ```
        
2. **데이터 삽입**:
    - 새로운 데이터 항목을 삽입할 때, 기존 데이터는 변경되지 않습니다. 예를 들어:
        
        ```sql
        INSERT INTO user_activity (user_id, action) VALUES (1, 'login');
        ```
        
3. **데이터 조회**:
    - 특정 시간대의 데이터를 조회하거나, 과거의 데이터 상태를 분석할 수 있습니다. 예를 들어, 특정 사용자의 활동 내역을 조회할 수 있습니다:
        
        ```sql
        SELECT * FROM user_activity WHERE user_id = 1;
        ```
        

### 장점

1. **데이터 무결성**:
    - 데이터가 변경되지 않기 때문에 원본 데이터의 무결성을 유지할 수 있습니다.
2. **변경 이력 추적**:
    - 데이터의 변동 이력을 추적할 수 있어 과거의 상태를 검토하거나 분석할 수 있습니다.
3. **사후 분석**:
    - 변경 이력을 바탕으로 데이터의 추세를 분석하거나, 이상 징후를 감지할 수 있습니다.

### 단점

1. **저장 공간**:
    - 데이터가 계속 추가되기 때문에 저장 공간이 점점 더 많이 필요합니다.
2. **데이터 관리**:
    - 데이터가 계속 증가하므로, 데이터 정리나 관리가 어려워질 수 있습니다. 예를 들어, 오래된 데이터를 별도의 아카이브로 이동하는 작업이 필요할 수 있습니다.
3. **성능 문제**:
    - 데이터가 많아질수록 조회 성능에 영향을 미칠 수 있습니다. 이를 해결하기 위해 인덱싱이나 파티셔닝 등의 기술을 사용할 수 있습니다.

### 예제)

### PageViews table 생성

- 각 레코드는 회사 웹사이트의 페이지를 보고 있는 고객을 나타냄
- 실제 테이블에는 조회된 페이지, 참조 URL, 사용자의 브라우저 버전 등에 대한 속성을 저장하는 수십 개 이상의 열이 포함

```sql
CREATE TABLE PageViews (
	Customerid int, 
	ViewTime timestamp,
	UrlPath varchar (250), 
	utm_medium varchar (50)
);

INSERT INTO PageViews
	VALUES (100, '2020-06-01 12:00:00', '/home', 'social'); 
INSERT INTO PageViews
	VALUES(100, '2020-06-01 12:00:13', '/product/2554', NUL); 
INSERT INTO PageViews
	VALUES (101, '2020-06-01 12:01:30', '/product/6754', 'search'); 
INSERT INTO PageViews
	VALUES (102, '2020-06-02 7:05:00' '/home', NULL); 
INSERT INTO PageViews
	VALUES (101, '2020-06-02 12:00:00', '/product/2554', 'social');
```

## 데이터 모델 정의

### 1. 각 고객이 거주하는 국가 식별

- 하루에 사이트의 각 UrIPath에 대한 페이지 보기는 몇 번인가?
- 각 국가의 고객이 매일 생성하는 페이지 뷰는 몇 개인가?

### 2. 속성 설정

- 데이터 모델의 세분성(=일 단위)
- 3가지 속성
    - 페이지 보기의 날짜(타임스탬프 필요 없음)
    - 페이지 보기의 UrlPath
    - 페이지를 보는 고객이 거주하는 국가

### 3. 요구되는 측정 항목

- 페이지 조회 수

### 모델의 구조

```sql
CREATE TABLE pageviews_daily ( 
	view_date date,
	url_path varchar(250), 
	customer_country varchar(50),
	view_count int 
);

INSERT NITO pageviews_daily
	(view_date, url_path, customer_country, view_count) 
SELECT
	CAST(p.ViewTime as Date) AS view_date, 
	p.UrlPath AS url_path,
	c.CustomerCountry AS customer_country, 
	COUNT(*) AS view_count
FROM PageViews p
LEFT JOIN Customers c ON c.CustomerId = p.CustomerId 
GROUP BY
	CAST(p.ViewTime as Date), 
	p.UrlPath,
	c. CustomerCountry;
```

⇒ 각 국가의 고객이 매일 생성하는 페이지 뷰 수?

```sql
SELECT
	view_date, 
	customer_country, 
	SUM(view_count)
FROM pageviews_daily
GROUP BY view_date, customer_country 
ORDER BY view_date, customer_country;
```

## 모델 업데이트하기 위한 2가지 옵션

### 1. pageviews_daily 테이블을 자르고 처음 채우기 작업에 사용한 것과 동일한 INSERT 문을 실행한다. ⇒ 모델을 완전히 새로고침

- 덜 복잡함
- 모델을 구축하는 분석가 측에서 논리적 오류를 일으킬 가능성이 적음
- 단, 모델 전체의 새로고침은 Pageviews 및 Customers 데이터 세트가 증가함에 따라 런타임도 함께 증가하게 되므로 주의가 필요함

### 2. Pageviews의 새 레코드만 pageviews_daily로 로드한다. ⇒ 모델을 증분으로 새로고침

- 더 복잡함
- 큰 데이터 세트로 작업할 때 런타임을 줄일 수 있음
- **주의 사항!!**
    - pageviews_daily 테이블 → 날짜별로 세분화(타임 스탬프가 없는 날짜)
    - PageViews 테이블 → 수집된 새 레코드는 전체 타임 스탬프로 세분화
    - **결과**
        
        ### 1. **타임스탬프 정보 손실**
        
        - **문제**: `pageviews_daily` 테이블에는 날짜별로 `view_count`가 집계됩니다. 하지만, `PageViews` 테이블에는 `ViewTime`이라는 타임스탬프가 포함되어 있습니다. 이로 인해 `PageViews` 테이블의 시간 단위 정보가 `pageviews_daily` 테이블에 저장될 때 손실됩니다.
        - **상세 설명**: `PageViews` 테이블의 타임스탬프 정보가 `pageviews_daily` 테이블로 이동할 때, 시간 단위 정보가 제거되고 날짜 단위로만 집계됩니다. 이로 인해 상세한 시간 분석이 불가능해지고, 특정 시간대의 트래픽 패턴을 파악할 수 없습니다.
        
        ### 2. **데이터 집계의 정확성 문제**
        
        - **문제**: 데이터 집계 과정에서 `GROUP BY`절에 포함된 필드와 `LEFT JOIN`으로 결합된 필드 간에 일관성 문제나 집계 오류가 발생할 수 있습니다.
        - **상세 설명**: `PageViews` 테이블의 `CustomerId`와 `Customers` 테이블의 `CustomerId`가 일치하지 않는 경우, `LEFT JOIN` 결과에 `NULL`이 포함될 수 있습니다. 이 경우 `customer_country` 필드에 `NULL`이 포함될 수 있으며, `pageviews_daily` 테이블의 `customer_country` 값이 예상과 다를 수 있습니다.
        - **문제 해결**: `JOIN`된 결과에서 `NULL` 값을 처리하기 위해 `COALESCE`를 사용하여 기본 값을 제공하거나, 데이터 정합성을 보장하기 위해 사전 검증 및 클린징을 수행할 수 있습니다.
        
        ### 3. **중복 데이터 문제**
        
        - **문제**: `PageViews` 테이블에서 중복된 `view_date`, `url_path`, `customer_country` 조합이 있을 경우, 집계 결과에 영향을 미칠 수 있습니다.
        - **상세 설명**: 만약 `PageViews` 테이블에서 동일한 `view_date`, `url_path`, `customer_country` 조합의 레코드가 여러 개 존재하면, `COUNT(*)`는 모든 레코드를 포함하여 집계합니다. 이는 중복 데이터가 포함된 `pageviews_daily` 테이블에 부정확한 `view_count`를 저장할 수 있습니다.
        - **문제 해결**: 중복 데이터를 처리하기 위해, `DISTINCT`를 사용하여 중복된 레코드를 제거하거나 데이터 정제 작업을 수행할 수 있습니다.
        
        ### 4. **성능 문제**
        
        - **문제**: 대량의 데이터가 `PageViews` 테이블에 저장되면, `INSERT INTO ... SELECT ...` 쿼리의 성능이 저하될 수 있습니다.
        - **상세 설명**: 대량의 데이터를 집계하고 삽입하는 과정에서 쿼리 성능이 저하되거나, 데이터 삽입 작업이 느려질 수 있습니다. 이로 인해 데이터 처리 시간이 길어질 수 있습니다.
        - **문제 해결**: 성능 최적화를 위해 인덱스를 추가하거나, 쿼리의 효율성을 개선하는 작업이 필요합니다. 예를 들어, 집계 및 삽입 작업을 배치로 나누어 처리하거나, 필요한 경우 데이터 파티셔닝을 고려할 수 있습니다.
        
        ### 5. **데이터 정합성 문제**
        
        - **문제**: `PageViews` 테이블에서 새로운 데이터가 추가되거나 수정될 때 `pageviews_daily` 테이블의 데이터와 일치하지 않을 수 있습니다.
        - **상세 설명**: `pageviews_daily` 테이블은 `PageViews` 테이블의 스냅샷을 기반으로 하므로, `PageViews` 테이블에 새로운 데이터가 추가되거나 기존 데이터가 변경되면 `pageviews_daily` 테이블의 데이터가 최신 상태로 유지되지 않을 수 있습니다.
        - **문제 해결**: 주기적으로 `pageviews_daily` 테이블을 업데이트하거나, ETL(Extract, Transform, Load) 프로세스를 통해 데이터를 동기화하는 방법을 사용할 수 있습니다.
        

- 더 나은 접근 방식
    - 가장 최근 일(또는 테이블의 단위에 따라 주, 월 등)에 더 많은 데이터가 로드되었다고 가정
        1. **기존 데이터 백업**: `pageviews_daily`에서 최신 날짜 이전의 데이터를 `tmp_pageviews_daily`에 복사합니다.
        2. **새 데이터 추가**: `PageViews` 테이블에서 최신 날짜 이후의 데이터를 집계하여 `tmp_pageviews_daily`에 추가합니다.
        3. **기존 데이터 삭제**: 기존 `pageviews_daily` 테이블의 모든 데이터를 삭제(TRUNCATE)합니다.
        4. **테이블 교체**: `tmp_pageviews_daily`의 데이터를 `pageviews_daily`로 복사하여 최신 상태로 업데이트합니다.
        5. **정리**: `tmp_pageviews_daily` 테이블을 삭제하여 정리합니다.
        
        ⇒ 데이터의 **일관성**과 **최신성**을 보장
        
        - 코드
            
            ### 1. `tmp_pageviews_daily` 테이블 생성
            
            **절차**:
            
            ```sql
            CREATE TABLE tmp_pageviews_daily AS
            SELECT *
            FROM pageviews_daily
            WHERE view_date < (SELECT MAX(view_date) FROM pageviews_daily);
            ```
            
            **설명**:
            
            - `tmp_pageviews_daily`라는 이름의 새로운 테이블을 생성합니다.
            - 이 테이블에는 현재 `pageviews_daily` 테이블에서 가장 최근 날짜(`MAX(view_date)`)보다 이전 날짜의 모든 데이터가 포함됩니다. 즉, 가장 최근 날짜를 제외한 이전 날짜의 모든 데이터가 포함됩니다.
            
            ### 2. 새 데이터 삽입
            
            **절차**:
            
            ```sql
            INSERT INTO tmp_pageviews_daily (view_date, url_path, customer_country, view_count)
            SELECT
                CAST(p.ViewTime AS DATE) AS view_date,
                p.UrlPath AS url_path,
                c.CustomerCountry AS customer_country,
                COUNT(*) AS view_count
            FROM PageViews p
            LEFT JOIN Customers c ON c.CustomerId = p.CustomerId
            WHERE p.ViewTime >= (SELECT MAX(view_date) FROM pageviews_daily)
            GROUP BY CAST(p.ViewTime AS DATE), p.UrlPath, c.CustomerCountry;
            ```
            
            **설명**:
            
            - `PageViews` 테이블에서 가장 최신 날짜 이후의 모든 데이터를 집계하여 `tmp_pageviews_daily` 테이블에 삽입합니다.
            - `LEFT JOIN`을 사용하여 `Customers` 테이블과 결합하여 `customer_country` 정보를 가져옵니다.
            - 집계는 날짜별로(`CAST(p.ViewTime AS DATE)`), `url_path`와 `customer_country`별로 수행됩니다.
            
            ### 3. `pageviews_daily` 테이블 데이터 삭제
            
            **절차**:
            
            ```sql
            TRUNCATE TABLE pageviews_daily;
            ```
            
            **설명**:
            
            - 기존 `pageviews_daily` 테이블의 모든 데이터를 삭제합니다.
            - `TRUNCATE` 명령은 테이블의 모든 데이터를 제거하지만 테이블 구조와 정의는 유지합니다. 데이터 삭제가 빠르고 효율적입니다.
            - `DROP` 명령을 사용할 경우, 처음 설정된 권한이 복사되지 않아 권한을 잃을 수 있기 때문에 사용하지 않습니다.
            
            ### 4. `pageviews_daily` 테이블에 새 데이터 삽입
            
            **절차**:
            
            ```sql
            INSERT INTO pageviews_daily
            SELECT * FROM tmp_pageviews_daily;
            ```
            
            **설명**:
            
            - `tmp_pageviews_daily` 테이블의 모든 데이터를 `pageviews_daily` 테이블에 삽입합니다.
            - 이제 `pageviews_daily` 테이블은 이전 데이터와 새로 집계된 데이터가 결합된 최신 상태로 업데이트됩니다.
            
            ### 5. `tmp_pageviews_daily` 테이블 삭제
            
            **절차**:
            
            ```sql
            DROP TABLE tmp_pageviews_daily;
            ```
            
            **설명**:
            
            - 더 이상 필요 없는 `tmp_pageviews_daily` 테이블을 삭제합니다.
            - 이 단계는 불필요한 테이블을 정리하여 데이터베이스를 깨끗하게 유지하는 데 도움을 줍니다.