# 1-1. 도커(Docker)
**도커(docker)** 는 컨테이너(container)라고 부르는 패키지 형태로 소프트웨어를 배포하는 OS-level의 가상화 기술을 사용한 PaaS(Platform as a Service) 제품입니다. 이 때, 컨테이너를 관리하는 소프트웨어를 도커 엔진(Docker Engine)이라고 부른다.

- 주로 도커는 작은 규모에서, K8s는 큰 규모의 기업에서 사용된다.

---
### Ubuntu 도커 설치
https://docs.docker.com/engine/install/ubuntu/
==> 참고: net-tools도 설치했음

---
## 1-1-1. 가상화(virtualization)
==> "물리적인 자원을 논리적인 자원으로 변환해서 사용하는 것"


---

## 1-1-2. 가상화의 종류

### 1) 호스트 가상화(Host virtualization)

![](https://i.imgur.com/qFI88Ge.png)


### 2) 하이퍼바이저 가상화(Hypervisor virtualization)
- 전 가상화(Full virtualization): 하드웨어를 가상화
- 반 가상화(Para-virtualization): 하드웨어를 가상화하지는 않음


![](https://i.imgur.com/uEYWl1g.png)


### 3) OS level 가상화(OS level virtualization), 컨테이너 가상화(Container virtualization)

![](https://i.imgur.com/JprXkT3.png)

### 4) 도커의 기본 개념

![](https://i.imgur.com/fTfDIwR.png)

---

# 1-2. 도커가 필요한 이유


![](https://i.imgur.com/8qXGG93.png)


![](https://i.imgur.com/zKTCBBk.png)

![](https://i.imgur.com/qsarE6p.png)


---
# 1-3. 도커의 구조

## 1-3-1. 도커 엔진(Docker Engine)
- 애플리케이션을 컨테이너화 하기 위한 오픈소스 컨테이너화 기술(open source containerization technology)
- 도커 엔진은 다음과 같은 클라이언트-서버 역할을 한다.
	- dockerd와 같은 데몬 프로세스가 실행되는 서버
	- 도커 데몬과 의사소통하기 위한 API 역할
	- 커맨드 라인 인터페이스(CLI) 클라이언트 docker


![](https://i.imgur.com/UdCCbFP.png)


![](https://i.imgur.com/cm6by86.png)

---
## 1-3-2. 도커 데몬(Docker Daemon, dockerd)
- 호스트(host)에서 메모리에 상주하며 백그라운드에서 컨테이너를 관리하는 프로세스
- 클라이언트의 요청을 기다리고 있다가 요청이 발생하면 이에 적절히 대응함
- 즉, 메모리에 상주하면서 특정 요청이 오면 즉시 대응할 수 있도록 대기 중인 프로세스를 의미
- 도커 사용자는 도커 데몬과 통신함

## 1-3-3. 도커 이미지(Docker Image)
- 도커 이미지는 도커 컨테이너를 실행하기 위해 필요한 모든 것을 모아놓은 패키지
- 기본적으로 코드, 라이브러리 및 컨테이너가 어떻게 인스턴스화 되어야 하는지에 대한 내용 포함
- 해당 소프트웨어 구성물이 어떻게 실행되어야 하는지도 포함
- 도커 이미지는 가상 머신 환경의 스냅샷이라고도 볼 수 있음
- 즉, 실행 중인 도커 컨테이너의 특정 시점을 나타낸다라고 할 수 있음

## 1-3-4. 도커 컨테이너(Docker Container)
- 실행 가능한 도커 이미지의 인스턴스
- 하나의 프로세스라고도 볼 수 있음(다른 프로세스들과 완전히 분리된)
- 도커 컨테이너는 가상화된 런타임 환경
- 런타임(runtime): 프로그램이 실행되고 있는 동안의 동작을 의미


![](https://i.imgur.com/9VRWhUL.png)

![](https://i.imgur.com/CJTjUb8.png)

![](https://i.imgur.com/tWTJxmW.png)

![](https://i.imgur.com/ZcALLsP.png)


## 1-3-5. 도커 레지스트리(Docker Registry)
- 도커 이미지 저장소
- 도커 이미지가 보관되는 곳
- 기본적으로 도커 허브(Docker Hub)에 있는 이미지를 찾도록 설정되어 있음
- https://hub.docker.com/ ==> 앞으로 자주 들어가게 될 것임!


---
## 1-3-6. 도커파일-이미지-컨테이너

![](https://i.imgur.com/lI1JhMv.png)

---
## 1-3-7. 도커 엔진의 변화

![](https://i.imgur.com/kPTWYvx.png)


![](https://i.imgur.com/7p7mhrh.png)

![](https://i.imgur.com/cRjVgNM.png)

![](https://i.imgur.com/7alI1y6.png)

---
## 1-3-8. containerd vs runc 차이점

![](https://i.imgur.com/0H2an4a.png)

- runc는 OCI(Open Container Image) 인터페이스를 실행하기 위한 lowest level 구성 요소
- runc는 containerd의 구성요소로써 커널 레벨에서 컨테이너를 실행한다.
- containerd는 컨테이너 라이프 사이클을 완벽하게 관리하는 컨테이너 런타임이다.
	- 컨테이너 라이프 사이클(container life cycle): 이미지 전송/저장부터 컨테이너 실행 및 네트워크 관리 등을 포함
- containerds는 네트워크, 이미지 전송/저장 등과 같이 runc보다 더 포괄적으로 관여하는 부분이 많은 반면, runc는 container를 실행하는 그 자체의 기능에만 집중한다. 그러니까 containerd는 runc가 컨테이너를 잘 실행할 수 있도록 도와준다고 보면 된다.
- 여기서 좀 더 넓게 보면 도커 엔진은 유저의 커맨드를 입력받고 도커 레지스트리에서 이미지를 다운로드 받는 등의 일을 한다.

---
## 1-3-9. OCI(Open Container Image) 
- 컨테이너 표준 사양을 책정하기 위해 2015년 6월에 만들어진 단체
- 처음에는 도커가 사실상 컨테이너의 표준이었는데, 시간이 지나면서 다양한 컨테이너 런타임이 생겨나게 되어 업계 표준이 필요한 상황.
- 도커, CoreOS, 구글, IBM, 레드햇, AWS, VMware, HP, EMC, Pivotal, 마이크로소프트, 리눅스 파운데이션 등 참가
- 2017년 7월에 OCI v1.0 발표(이 때, 도커가 구현한 것이 runc)

---

# 2-1. 도커 hello-world

![](https://i.imgur.com/3cXxVB8.png)

---
## 2-1-1. 도커 이미지 확인
![](https://i.imgur.com/7ccSXBg.png)

---
## 2-1-2. 도커 컨테이너 확인

![](https://i.imgur.com/xLMehKc.png)

- 작동 중인 컨테이너 확인
- $ docker container ls


![](https://i.imgur.com/tfxC3Ya.png)

- 모든 컨테이너 확인
- $ docker container ls -a

##### Tip: "Docker 로고에 눈이 있는 놈은 옛날 버전이다. 잘 구분해서 쓸 것"

![](https://i.imgur.com/hdUXeMy.png)
==> 옛날 놈


![](https://i.imgur.com/fB8kIf9.png)
==> 요즘 놈


---
## 2-1-3. 도커 containerd 확인

![](https://i.imgur.com/3cpWJzo.png)

- $ sudo -i
- cd /run/docker
- $ ll
- $ exit

![](https://i.imgur.com/93PMAib.png)

- 아무것도 없음을 확인


![](https://i.imgur.com/DfUBUBs.png)

- moby: 초기 도커 프로젝트 이름

---

# 3-1. docker pull

### 3-1-1. docker pull

![](https://i.imgur.com/HDnXWzg.png)
- $ docker image pull ubuntu

### 3-1-2. pull된 도커 이미지는 어디에 저장될까?

![](https://i.imgur.com/7y2IXOe.png)


![](https://i.imgur.com/RgeAaPS.png)

---
# 4-1. docker container run


![](https://i.imgur.com/nakAecU.png)


![](https://i.imgur.com/bPTZ1oi.png)

### docker container run
- 이미지는 컨테이너로 변화되어 하나의 인스턴스가 됨
- 실행 상태의 컨테이너는 IP 주소를 가지는 하나의 독립된 서버처럼 동작함
- 각 컨테이너는 고유의 IP 주소와 포트 번호를 가지고 있음
- 컨테이너는 실행할 때마다 새로운 IP 주소를 가지게 됨(이전 이력과 관계없음)

---

# 5-1. 컨테이너 네트워크

## 5-1-1. (터미널 1) 컨테이너 내부에서 bash shell 실행

$ docker container run -it ubuntu /bin/bash
- i(interactive) 옵션: 키보드 입력을 컨테이너 표준 입력에 연결해 컨테이너 shell에 보냄
- t(tty) 옵션: 터미널을 통해 대화형 조작이 가능하게 함

![](https://i.imgur.com/VLJHq0j.png)

	- 운영체제처럼 보인다. 그렇다면 ubuntu 컨테이너는 운영체제일까?
	- 여기서 드래그한 root는 무엇일까?




![](https://i.imgur.com/McQgh3x.png)

---
## 5-1-2. (터미널 2) 새로운 터미널을 열고 컨테이너 ls 확인

![](https://i.imgur.com/qDiUxNv.png)


- 'Up 7 minutes' ==> exited가 아님, 왜일까?



![](https://i.imgur.com/B2950nT.png)

---
## 5-1-3. 터미널 2에서 터미널 1에 실행 중인 컨테이너에 접속하기

![](https://i.imgur.com/Kq16N3r.png)
- docker exec -it {컨테이너ID} /bin/bash

---
## 5-1-4. 터미널 2에서 터미널 1에 실행 중인 컨테이너 종료시키기

![](https://i.imgur.com/24cuvWg.png)

- docker container stop {컨테이너ID}

![](https://i.imgur.com/D6oKJCI.png)

- 터미널 1에서의 변화: root@bd2acd2c4c10에서 종료되어 **ubuntu@ip-172-31-12-95**:**~**$로 바뀜. 실습하면서 터미널 1 잘 관찰할 것
- Q1. 꺼진 컨테이너로 다시 들어가는 방법은?: docker restart {컨테이너ID 또는 이름}
- Q2. 전체 삭제 방법은? 

---

# 6-1. 도커 이미지 변경 후 저장
## 6-1-1. 도커 이미지 변경?

![](https://i.imgur.com/IlxtYUh.png)

![](https://i.imgur.com/5F2twjg.png)


## 6-1-2. 호스트 <-> 컨테이너 간 파일 전송

![](https://i.imgur.com/LSfiuro.png)
## 6-1-3. 도커 이미지 변경 후 저장하기

![](https://i.imgur.com/UQq56fj.png)
- (터미널 1)$ docker container run -it ubuntu /bin/bash
- (터미널 1)$ ifconfig


![](https://i.imgur.com/wTfNF3Y.png)

- (터미널 1)$ apt-get update && apt-get install net-tools


![](https://i.imgur.com/ZZpUYlQ.png)

- (터미널 1)$ ifconfig



![](https://i.imgur.com/UHuAkB5.png)

- (터미널 2)$ docker container ls



![](https://i.imgur.com/Cdiweur.png)

- (터미널 2)$ docker container commit {컨테이너ID} my-ubuntu:0.1
- (터미널 2)$ docker image ls


![](https://i.imgur.com/JNZHmbu.png)

- (터미널 1) 도커 이미지 변경 후 저장하기
- (터미널 1) exit
- (터미널 1)$ docker image ls
- (터미널 1)$ docker container run -it my-ubuntu:0.1 /bin/bash
- (터미널 1) ifconfig
- (터미널 1) exit



---

# 7-1. 컨테이너 <-> 호스트 간 파일 전송


![](https://i.imgur.com/bv3vez5.png)

![](https://i.imgur.com/sXbj9Ke.png)







