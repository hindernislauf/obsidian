# 5. DIP(Dependency Injection Principle): 의존성 역전 원칙
- 의존성(의존관계) 역전 원칙이란 "추상화에 의존하되, 구체화에 의존하면 안 된다"는 원칙이다.
- 즉, 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안 된다는 말이다.
- 대신 저수준 모듈이 고수준 모듈에서 정의한 추상 타입에 의존해야 한다.
---


![[DIP 원칙.png]]



	고수준 모듈: 어떤 의미 있는 단일 기능을 제공하는 모듈(Interface, 추상 클래스)
	저수준 모듈: 고수준 모듈의 기능을 구현하기 위해 필요한 하위 기능의 실제 구현(메인클래스, 객체)

주의해야할 점은, 고수준 클래스가 저수준 클래스를 사용한다고 고->저의 의존 관계가 자연스러워 보일 수 있다는 점이다. 하지만 저수준 클래스는 빈번하게 변경되고, 새로운 것이 추가될 때마다 고수준 클래스가 영향을 받기 쉬우므로 의존관계를 역전시켜야 한다.

아래 예시를 통해 DIP 원칙을 확인할 수 있다.

---

## 5-1. DIP를 위반한 코드 예제

![[DIP 위반.png]]

```java
public class Kid {
    private Robot toy;

    public void setToy(Robot toy) {
        this.toy = toy;
    }

    public void play() {
        System.out.println(toy.toString());
    }
}
```

```java
public class Main{
    public static void main(String[] args) {
        Robot robot = new Robot();
        Kid k = new Kid();
        k.setToy(robot);
        k.play();
    }
}
```

- 위 코드에서 `Kid` 는 `robot`이라는 구체적인 객체에 의존하고 있다. 이런 경우 `Kid` 가 가지고 노는 장난감의 종류가 변경될 때 다음과 같이 `Kid` 클래스를 수정해야 한다.

```java
public class Kid {

    private Robot toy;
    private Lego toy; //레고 추가
    
    // 아이가 가지고 노는 장난감의 종류만큼 Kid 클래스 내에 메서드가 존재해야함.
    public void setToy(Robot toy) {
        this.toy = toy;
    }
    public void setToy(Lego toy) {
        this.toy = toy;
    }

    public void play() {
        System.out.println(toy.toString());
    }
    
}
```

`Kid` 라는 고수준 모듈이 변하기 쉬운 저수준 모듈(장난감)에게 의존하면 변화에 직접적으로 노출된다. 장난감 하나를 더 추가하기 위해서 `Kid` 클래스까지 수정이 일어나기 때문이다.

---

## 5-2. DIP를 준수한 코드 예제

DIP는 의존 관계를 맺을 때 자신보다 변화하기 쉬운 것을 의존해서는 안 되고, 거의 변화가 없는 개념에 의존해야 한다.

- 아이가 장난감을 가지고 노는데 어떤 경우에는 로봇을, 어떤 경우에는 레고를 가지고 놀 것이다. 이 경우에서 변하기 쉬운 것은 **로봇, 레고, 모형 자동차**다.
- 하지만 **아이가 장난감을 가지고 논다**는 사실은 변하기 어려운 개념이다.

![[DIP 준수.png]]


- 위 사진과 같이 아이가 구체적인 객체들(로봇, 레고, 모형 자동차 등)을 직접 의존하지 않고 장난감이라는 추상 클래스와 의존 관계를 맺도록 설계했다. 로봇, 레고, 모형 자동차 같은 구체적인 객체들도 상위 개념인 장난감 클래스에 의존하고 있다.
- 이러한 설계 방법에 의하면 장난감의 종류가 아무리 추가되고 변경되어도 아이 객체에는 영향을 미치지 않는다.

이것을 코드로 구현하면 다음과 같다.

```java
public class Kid {
    private Toy toy;

    public void setToy(Toy toy) {
        this.toy = toy;
    }

    public void play() {
        System.out.println(toy.toString());
    }
```

- 위 코드에 의하면 더이상 `Kid` 클래스 내에서 구체적인 장난감 객체들을 생성하지 않는다. 
- 대신 `Kid` 클래스는 장난감이라는 큰 개념의 클래스를 의존하고 있다.
- 단순히 setToy() 메서드로 가지고 노는 장난감을 바꿀 수 있다.

만약 아이가 로봇을 가지고 놀고 싶다면, Toy라는 추상 클래스를 상속 받아 다음과 같이 `Robot` 객체를 구현하면 된다.

```java
public class Robot extends Toy {
    public String toString() {
        return "Robot";
    }
}
```

```java
public class Main{
    public static void main(String[] args) {
        Toy robot = new Robot();
        Kid k = new Kid();
        k.setToy(robot);
        k.play();
    }
}
```

레고로 변경하고 싶은 경우에도 다음과 같이 `Toy` 클래스를 상속 받는 `Lego` 클래스를 구현해주면 된다.

```java
public class Lego extends Toy {
    public String toString() {
        return "Lego";
    }
}
```

```java
public class Main{
    public static void main(String[] args) {
        Toy lego = new Lego();
        Kid k = new Kid();
        k.setToy(lego);
        k.play();
    }
}
```

새로운 장난감을 추가했지만, `Kid` 클래스의 코드에는 어떠한 변화도 일어나지 않고, 어떠한 영향도 미치지 않았다. DIP를 만족했기 때문에 변화에 유연한 시스템이 된 것이다.

## 요약
	의존성 역전 원칙이란 객체는 구체적인 객체가 아닌 추상화에 의존해야 한다는 법칙이다. 자신보다 변하기 쉬운 것에 의존해서는 안 된다. 이를 만족하면 의존성 주입(DI)이라는 기술로 변화를 쉽게 수용할 수 있는 코드를 작성할 수 있다.


