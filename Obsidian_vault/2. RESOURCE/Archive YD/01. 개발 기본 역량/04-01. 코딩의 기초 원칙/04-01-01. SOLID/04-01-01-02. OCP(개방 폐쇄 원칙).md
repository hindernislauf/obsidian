# 2. OCP(Open-Closed Principle): 개방 폐쇄 원칙
	"Software Entity(클래스, 모듈, 함수 등)는 확장에 대해서는 열려 있어야 하지만, 변경에 대해서는 닫혀 있어야 한다." - Robert C. Martin


- 객체의 확장은 개방적으로, 객체의 수정은 폐쇄적으로 대해야 한다는 원칙.
- 기능이 변하거나 확장되는 것은 가능하지만, 그 과정에서 기존의 코드가 수정되지 않아야 한다.




아래 예제를 통해 OCP에 대해 알 수 있다.
---

![[OCP 원칙.png]]
## 2-1. OCP를 위반한 코드 예제

```java
public class NOT_OCP운전자 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		
		소나타 운전자 = new 소나타();
		  운전자.drive();
		
		그랜저 운전자2 = new 그랜저();
		  운전자2.drive();
		
		BMW 운전자3 = new BMW();
		  운전자3.drive();
	}

}

class 소나타{	
	void drive() {
		System.out.println("나는 소나타를 운전한다.");
	}
}

class 그랜저{	
	void drive() {
		System.out.println("나는 그랜저를 운전한다.");
	}
}

class BMW{	
	void drive() {
		System.out.println("나는 BMW를 운전한다.");
	}
}
```

- 위 코드에서는 각각의 소나타, 그랜저, BMW 클래스에서 drive()라는 메서드를 구현하고 있다.
- 즉, 이 코드에서는 운전자 객체가 생성될 때부터 각 차량 클래스에 과하게 의존하고 있는 것이다.
- 기존에 BMW를 몰던 운전자3의 차가 소나타로 바뀌면, 운전자3의 객체를 다시 생성해주어야 한다. 이렇게 코드 자체가 수정되는 상황은 수정에 폐쇄적인 OCP를 위반한다.

## 2-2. OCP를 준수한 코드 예제

```java
public class OCP운전자 {

	public static void main(String[] args) {
		
		자동차[] 운전자 = new 자동차[3];
		
		운전자[0] = new 소나타();
		운전자[1] = new 그랜저();
		운전자[2] = new BMW();
		
		for(int i=0; i<운전자.length; i++) {
			운전자[i].drive();
		}

	}

}

class 자동차{
	String myCar="자동차";
	void drive() {
		System.out.printf("나는 %s 를 운전할 수 있다. \n",  myCar);
	}
}

class 소나타 extends 자동차{
	public 소나타() {
		myCar = "소나타";
	}	
}

class 그랜저 extends 자동차{	
	public 그랜저() {
		myCar = "그랜저";
	}
}

class BMW extends 자동차{	
	public BMW() {
		myCar = "BMW";
	}
}
```

- 각각의 그랜저, 소나타, BMW 클래스들은 더 추상적인 개념인 '자동차'클래스를 상속받고 있다. 
- 이 코드에서 drive() 메서드는 자동차가 바뀌더라도 변경되지 않는다. 
- 즉, 자동차의 변경과 확장에 대해서는 개방되어 있고, 어떤 차를 타도 운전 방법은 수정되지 않게 폐쇄되어있는 코드인 것이다.
- - 예를 들어, 현대 자동차를 운전하는 운전자 하나를 더 만들어 코드를 확장하려고 한다면

```java
    Class 현대 extends 자동차 {
        public 현대() {
            myCar = "현대";
        }
    }
    
```

- 위와 같은 현대 클래스를 하나 추가하고, 다음과 같이 메인 메서드를 작성해주면 된다.

```java
	public static void main(String[] args) {
    
        운전자[3] = new 현대(); //추가
		운전자[3].drive();

	}
```

- 새로운 자동차가 하나 더 추가되었음에도, 기존 drive() 메서드나 자동차 클래스의 코드가 전혀 변경되지 않았음을 알 수 있다.


이렇게 코드를 작성해 어떠한 메신저로 변경되어도 클래스 하나만 추가하면 외부 변경에 유연하게 대응할 수 있다. 나아가 내부의 Production Code를 변경하지 않고 OCP 원칙을 지키는 코드를 완성할 수 있는 것이다.

- Production Code(기존에 짜여져 있는 코드)
- 처음의 코드 스크립트는 전체 작동 방식을 이해해야 한다. 현업에서 예를 들자면 관련 로직이 어떻게 작성되었고 작동하는지를 명확히 알아야 추가적인 작업이 가능한 코드인 것이다.
- 하지만 인터페이스를 통해 분리한다면 기존의 코드에는 변경이 없고, 단순히 하나의 클래스를 추가하고 overriding(부모 클래스에서 이미 정의한 메소드를 자식클래스가 같은 시그니쳐를 갖는 메소드로 정의하는 것)만 해준다면 자세한 동작 원리를 몰라도 사용할 수 있다.



## 요약
	확장에는 개방되고, 수정에는 폐쇄되어야 한다. 즉, 기능이 변하거나 확장되는 것은 가능하지만 그 과정에서 기존의 코드가 수정되지 않아야 한다는 원칙이다.